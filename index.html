<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מערכת ניטור יין</title>
     <link rel="icon" href="image_00b206.png" type="image/png">
    <link href="https://fonts.googleapis.com/css2?family=Heebo:wght@300;400;700&family=Playfair+Display:wght@400;700&family=Noto+Sans+Hebrew:wght@300;400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://unpkg.com/@digicole/pdfmake-rtl/build/pdfmake.min.js"></script>
    <script src="https://unpkg.com/@digicole/pdfmake-rtl/build/vfs_fonts.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <link rel="stylesheet" href="t.css">
    <script>
        // Simple client-side authentication
        // Site password prompt configuration - set to false to disable auto-prompt
        const ENABLE_SITE_PASSWORD_PROMPT = false;
    </script>
</head>
<body class="preload">
    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div class="loading-spinner">
            <div class="spinner-border"></div>
            <p id="loadingText">טוען...</p>
        </div>
    </div>
    
    <script>
        // Firebase Authentication wrapper - will be initialized after Firebase loads
        let auth = null;
        
        // Wait for Firebase to be initialized
        function waitForFirebase() {
            return new Promise((resolve) => {
                const checkFirebase = setInterval(() => {
                    if (window.firebaseAuth) {
                        clearInterval(checkFirebase);
                        auth = window.firebaseAuth;
                        resolve();
                    }
                }, 100);
            });
        }
        
        // Firebase Auth helper functions
        async function signUpWithEmail(email, password) {
            await waitForFirebase();
            const userCredential = await window.firebaseCreateUser(auth, email, password);
            return userCredential.user;
        }
        
        async function signInWithEmail(email, password) {
            await waitForFirebase();
            const userCredential = await window.firebaseSignIn(auth, email, password);
            return userCredential.user;
        }
        
        async function signOutUser() {
            await waitForFirebase();
            await window.firebaseSignOut(auth);
        }
        
        function onAuthChanged(callback) {
            waitForFirebase().then(() => {
                window.firebaseOnAuthStateChanged(auth, callback);
            });
        }
        
        // Update Firebase connection status
        function updateFirebaseStatus(connected) {
            const statusEl = document.getElementById('firebaseStatus');
            if (!statusEl) return;

            const statusText = statusEl.querySelector('span');
            const isAuthenticated = Boolean(auth && auth.currentUser);
            if (!connected && !isAuthenticated) {
                statusEl.style.display = 'none';
                return;
            }

            statusEl.style.display = 'inline-flex';
            if (connected) {
                statusEl.classList.remove('disconnected');
                if (statusText) statusText.textContent = 'מחובר לענן';
            } else {
                statusEl.classList.add('disconnected');
                if (statusText) statusText.textContent = 'מנותק מהענן';
            }
        }

        function updateFirebaseStatusFromSnapshot(snapshot) {
            if (!snapshot || !snapshot.metadata) return;
            updateFirebaseStatus(!snapshot.metadata.fromCache);
        }
        
        // UI Helper Functions
        function showLoading(message = 'טוען...') {
            const overlay = document.getElementById('loadingOverlay');
            const text = document.getElementById('loadingText');
            if (overlay) {
                if (text) text.textContent = message;
                overlay.style.display = 'flex';
            }
        }
        
        function hideLoading() {
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
        }
        
        function showNotification(message, type = 'success') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `firebase-notification ${type}`;
            notification.innerHTML = `
                <i class="fas fa-${type === 'success' ? 'check-circle' : 'exclamation-circle'}"></i>
                <span>${message}</span>
            `;
            document.body.appendChild(notification);
            
            // Auto-remove after 3 seconds
            setTimeout(() => {
                notification.classList.add('fade-out');
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }
        
        // Firestore-based Access Management
        const AccessManagement = {
            ACCESS_KEY: 'userAccess',
            
            async grantAccess(targetEmail, projectId, allowEdit, allowFinance) {
                await waitForFirebase();
                const currentEmail = auth?.currentUser?.email;
                if (!currentEmail) throw new Error('Not authenticated');
                
                const accessId = Date.now().toString();
                const accessData = {
                    id: accessId,
                    ownerEmail: currentEmail,
                    userEmail: targetEmail,
                    projectId: projectId === 'all' ? null : projectId,
                    allowEdit: allowEdit || false,
                    allowFinance: allowFinance || false,
                    status: 'active',
                    createdAt: window.firestoreServerTimestamp()
                };
                
                await window.firestoreSetDoc(
                    window.firestoreDoc(window.firebaseDb, 'access', accessId),
                    accessData
                );
                return accessId;
            },
            
            async getActiveUsers() {
                await waitForFirebase();
                const currentEmail = auth?.currentUser?.email;
                if (!currentEmail) return [];
                
                const q = window.firestoreQuery(
                    window.firestoreCollection(window.firebaseDb, 'access'),
                    window.firestoreWhere('ownerEmail', '==', currentEmail),
                    window.firestoreWhere('status', '==', 'active')
                );
                
                const snapshot = await window.firestoreGetDocs(q);
                return snapshot.docs.map(doc => doc.data());
            },
            
            async revokeAccess(accessId) {
                await waitForFirebase();
                await window.firestoreUpdateDoc(
                    window.firestoreDoc(window.firebaseDb, 'access', accessId),
                    { status: 'revoked' }
                );
            },
            
            async checkAccess(userEmail, projectId) {
                await waitForFirebase();
                const q = window.firestoreQuery(
                    window.firestoreCollection(window.firebaseDb, 'access'),
                    window.firestoreWhere('userEmail', '==', userEmail),
                    window.firestoreWhere('status', '==', 'active')
                );
                
                const snapshot = await window.firestoreGetDocs(q);
                return snapshot.docs.find(doc => {
                    const data = doc.data();
                    return data.projectId === null || data.projectId === projectId;
                })?.data();
            },
            
            async getAccessData() {
                try {
                    await waitForFirebase();
                    const snapshot = await window.firestoreGetDocs(
                        window.firestoreCollection(window.firebaseDb, 'access')
                    );
                    const data = {};
                    snapshot.docs.forEach(doc => {
                        data[doc.id] = doc.data();
                    });
                    return data;
                } catch (e) {
                    return {};
                }
            },
            
            async saveAccessData(data) {
                try {
                    await waitForFirebase();
                    for (const [id, accessInfo] of Object.entries(data)) {
                        await window.firestoreSetDoc(
                            window.firestoreDoc(window.firebaseDb, 'access', id),
                            accessInfo
                        );
                    }
                } catch (e) {
                    console.error('Error saving access data:', e);
                }
            }
        };
    </script>
    <div class="hamburger-menu-btn" id="hamburgerBtn">
        <span></span>
        <span></span>
        <span></span>
    </div>
    <div class="sidebar" id="sidebar">
        <div class="sidebar-toggle-handle" onclick="toggleSidebar()">
            <i class="fas fa-angle-double-left" id="sidebarToggleIcon"></i>
        </div>
        <ul>
            <li><a href="#" onclick="closeSidebar(); showMainContent();">ראשי</a></li>
            <li><button onclick="openProjectManagementModal();">ניהול פרויקטים</button></li>
            <li><button onclick="openFinanceModal();">ניהול כספים</button></li>
            <li><button onclick="openCurrentProjectFinanceReportModal();">דוח כספי</button></li>
            <li><button onclick="openGlobalFinanceReportModal();">דוח כספי כולל</button></li>
            <li><button onclick="openFinanceYearlyModal();">דוח כספי לפי שנה</button></li>
            <li><button onclick="openInboxModal();">תיבת דואר <span id="inboxBadge" class="inbox-badge" style="display:none;">0</span></button></li>
            <li><button onclick="openRemindersModal();">תזכורות</button></li>
            <li><button onclick="openAccessControlModal();">ניהול גישה</button></li>
            <li><button onclick="openAccountSwitchModal();">חיבור חשבונות</button></li>
            <li class="divider"></li>
            <li><button onclick="openInstructionsModal()">הוראות</button></li>
            <li><button onclick="openTimelineModal()">ציר זמן</button></li>
        </ul>
        <div class="sidebar-footer">
            <div class="auth-section">
                <div class="auth-status" id="authStatus">לא מחובר</div>
                <div class="firebase-status" id="firebaseStatus" style="display:none;">
                    <i class="fas fa-circle"></i>
                    <span>מחובר לענן</span>
                </div>
                <button id="switchBackBtn" class="switch-back-btn" style="display:none;" onclick="switchToOwnAccount()">
                    <i class="fas fa-undo"></i> חזור לחשבון שלי
                </button>
                <button id="loginBtn">התחבר</button>
                <button id="changeSitePasswordBtn" class="change-password-btn" style="display:none;" onclick="openPasswordSetupModal()">שנה סיסמת אתר</button>
                <button id="logoutBtn" class="logout-btn" style="display:none;">יציאה</button>
            </div>
            <div class="divider"></div>
            <div class="zoom-controls">
                <button onclick="zoomIn()">+</button>
                <button onclick="zoomOut()">-</button>
            </div>
            <div class="theme-switch">
                מצב כהה:
                <label class="switch">
                    <input type="checkbox" id="darkModeToggle">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
    </div>
    <div class="sidebar-overlay" id="sidebarOverlay"></div>
    <!-- Reminder Popup Notification -->
    <div id="reminderPopupNotification" class="reminder-popup-notification" style="display:none;">
        <div class="reminder-popup-content">
            <div class="reminder-popup-icon">
                <i class="fas fa-bell"></i>
            </div>
            <div class="reminder-popup-text">
                <h4>תזכורת!</h4>
                <p id="reminderPopupText"></p>
            </div>
            <button class="reminder-popup-close" onclick="closeReminderPopup()">
                <i class="fas fa-times"></i>
            </button>
        </div>
    </div>
    <button class="card-fab" id="cardFab" aria-label="פתח כרטיס פרויקט">
        <img class="card-fab-icon" src="image_00b206.png" alt="" aria-hidden="true">
        <span class="sr-only">פתח כרטיס פרויקט</span>
    </button>
    <div class="login-modal" id="loginModal">
        <div class="login-modal-content">
            <button class="close-login-btn" onclick="closeLoginModal()">&times;</button>
            <h2>ברוכים הבאים!</h2>
            <p class="login-description-desktop">כדי לשמור את הנתונים שלך ולנהל גישה למשתמשים, יש להירשם עם אימייל וסיסמה. הנתונים שלך יישמרו בענן בצורה מאובטחת תחת החשבון שלך.</p>
            <p class="login-description-mobile">כדי לשמור את הנתונים שלך ולנהל גישה למשתמשים, יש להירשם עם אימייל וסיסמה. הנתונים שלך יישמרו בענן תחת החשבון שלך.</p>
            
            <!-- Registration Form (shown by default) -->
            <div class="email-form" id="registrationForm">
                <button class="google-btn" onclick="signInWithGoogle()">
                    <svg width="20" height="20" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/>
                        <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/>
                        <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/>
                        <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/>
                    </svg>
                    התחבר עם Google
                </button>
                <button class="google-btn redirect-login-btn" onclick="startRedirectLogin()" style="display: none;">
                    <svg width="20" height="20" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/>
                        <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/>
                        <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/>
                        <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/>
                    </svg>
                    התחבר באמצעות הפניה
                </button>
                <div class="login-separator">
                    <span>או</span>
                </div>
                <input type="email" id="registerEmailInput" placeholder="אימייל" required>
                <input type="password" id="registerPasswordInput" placeholder="סיסמה (לפחות 6 תווים)" required minlength="6">
                <div class="buttons">
                    <button class="register-btn" onclick="registerWithEmailPassword()">הרשם</button>
                </div>
                <button class="toggle-form-btn" onclick="toggleLoginMode()">כבר רשום? התחבר כאן</button>
            </div>
            
            <!-- Login Form (hidden by default) -->
            <div class="email-form" id="loginForm" style="display: none;">
                <button class="google-btn" onclick="signInWithGoogle()">
                    <svg width="20" height="20" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/>
                        <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/>
                        <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/>
                        <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/>
                    </svg>
                    התחבר עם Google
                </button>
                <button class="google-btn redirect-login-btn" onclick="startRedirectLogin()" style="display: none;">
                    <svg width="20" height="20" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/>
                        <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/>
                        <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/>
                        <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/>
                    </svg>
                    התחבר באמצעות הפניה
                </button>
                <div class="login-separator">
                    <span>או</span>
                </div>
                <input type="email" id="loginEmailInput" placeholder="אימייל" required>
                <input type="password" id="loginPasswordInput" placeholder="סיסמה" required>
                <div class="buttons">
                    <button class="login-btn" onclick="loginWithEmailPassword()">התחבר</button>
                </div>
                <button class="toggle-form-btn" onclick="toggleLoginMode()">עדיין לא נרשמת? הרשם כאן</button>
            </div>
            
            <button class="skip-btn" onclick="skipLogin()">המשך ללא התחברות</button>
        </div>
    </div>
    <div class="login-modal" id="passwordSetupModal">
        <div class="login-modal-content">
            <h2>הגדרת סיסמה לאתר</h2>
            <p>כדי להתחבר לאתר ממכשירים אחרים, אנא הגדר סיסמה לאתר. הסיסמה תשמש להתחברות עם האימייל שלך מכל מקום.</p>
            <div class="email-form">
                <input type="password" id="newSitePassword" placeholder="סיסמה חדשה לאתר" required minlength="6">
                <input type="password" id="confirmSitePassword" placeholder="אימות סיסמה" required minlength="6">
                <div class="buttons">
                    <button class="register-btn" onclick="saveSitePassword()">שמור סיסמה</button>
                    <button class="skip-btn" onclick="skipPasswordSetup()">דלג בינתיים</button>
                </div>
            </div>
        </div>
    </div>
    <div class="top-section-wrapper">
        <div class="container">
            <div class="project-header">
                <h2 id="currentProjectName">פרויקט ראשי</h2>
                <input type="text" id="editProjectNameInput" style="display:none;">
            </div>
            <div id="sharedAccessNotice" class="shared-access-notice"></div>
            <div class="stage-nav-container" id="stageNavContainer"></div>
        </div>
    </div>
    <div class="container">
        <div class="project-details-card" id="projectDetailsCard" style="visibility:hidden;">
            <div class="pull-handle" onclick="toggleCard()">
                <i class="fas fa-angle-double-right" id="pullHandleIcon"></i>
            </div>
            <div class="close-card-btn" onclick="closeCard()">&times;</div>
            <h4>פרטי פרויקט</h4>
            <div class="project-details-item" data-metric-id="wineName" data-section="wineDetails">
                <span class="detail-label">שם היין:</span>
                <span class="detail-value editable">--</span>
            </div>
            <div class="project-details-item" data-metric-id="vintageYear" data-section="wineDetails">
                <span class="detail-label">שנה:</span>
                <span class="detail-value editable">--</span>
            </div>
            <div class="project-details-item" data-metric-id="grapeVariety" data-section="wineDetails">
                <span class="detail-label">זן הענבים:</span>
                <span class="detail-value editable">--</span>
            </div>
            <div class="project-details-item" data-metric-id="vineyardSource" data-section="wineDetails">
                <span class="detail-label">מקור הענבים:</span>
                <span class="detail-value editable">--</span>
            </div>
            <div class="project-details-item" data-metric-id="generalNotes" data-section="wineDetails">
                <span class="detail-label">הערות נוספות:</span>
                <span class="detail-value editable">--</span>
            </div>
            <div class="project-details-item" data-metric-id="harvestDate" data-section="wineDetails">
                <span class="detail-label">תאריך בציר:</span>
                <span class="detail-value editable">--</span>
            </div>
            <button class="add-custom-property-btn" onclick="addCustomProperty()">+ הוסף שדה מותאם אישית</button>
        </div>
        <div id="currentStageContent">
            <div class="input-section" id="currentStageInputSection"></div>
        </div>
        <div class="stage-overview-container" id="stageOverviewContainer" style="display: none;">
            <h4>נתונים משלבים קודמים</h4>
            <div class="step-cards-grid" id="stepCardsGrid"></div>
        </div>
    </div>
    <div class="dashboard-section" id="fixedDashboardSection">
        <h2 id="fixedDashboardStageName"></h2>
        <div class="dashboard-grid" id="fixedDashboardGrid"></div>
        <div class="add-data-cube" onclick="openAddMetricModal()">
            <i class="fas fa-plus"></i>
            <span>הוסף מדד</span>
        </div>
    </div>
        <div id="addMetricModal" class="modal">
            <div class="modal-content add-metric-modal-content">
                <span class="close-button" onclick="closeAddMetricModal()">&times;</span>
                <h3><i class="fas fa-chart-line"></i> הוסף מדד חדש לשלב הנוכחי</h3>
                <label for="addMetricName"><i class="fas fa-tag"></i> שם המדד:</label>
                <input type="text" id="addMetricName" placeholder="למשל: בריקס נוסף">
                <button onclick="addNewMetric()"><i class="fas fa-plus"></i> הוסף</button>
            </div>
        </div>
        <div id="newProjectModal" class="modal">
            <div class="modal-content project-modal-content">
                <span class="close-button" onclick="closeNewProjectModal()">&times;</span>
                <h3>פרויקט חדש</h3>
                <label for="newProjectNameInput">שם הפרויקט:</label>
                <input type="text" id="newProjectNameInput" placeholder="למשל: יקב חדש">
                <div class="modal-actions">
                    <button onclick="confirmAddNewProject()">צור</button>
                    <button onclick="closeNewProjectModal()">ביטול</button>
                </div>
            </div>
        </div>
        <div id="customPropertyModal" class="modal">
            <div class="modal-content">
                <span class="close-button" onclick="closeCustomPropertyModal()">&times;</span>
                <h3>שדה מותאם אישית</h3>
                <label for="customPropertyNameInput">שם השדה:</label>
                <input type="text" id="customPropertyNameInput" placeholder="למשל: זן נוסף">
                <div class="modal-actions">
                    <button onclick="confirmAddCustomProperty()">הוסף</button>
                    <button onclick="closeCustomPropertyModal()">ביטול</button>
                </div>
            </div>
        </div>
        <div id="financeEditModal" class="modal">
            <div class="modal-content finance-modal-content">
                <span class="close-button" onclick="closeFinanceEditModal()">&times;</span>
                <h3>עריכת תנועה כספית</h3>
                <label for="financeEditAmount">סכום:</label>
                <input type="number" id="financeEditAmount" step="0.01" min="0">
                <label for="financeEditNotes">הערות:</label>
                <textarea id="financeEditNotes" rows="3" placeholder="הערות (אופציונלי)"></textarea>
                <div class="modal-actions">
                    <button onclick="saveFinanceEdit()">שמור</button>
                    <button onclick="closeFinanceEditModal()">ביטול</button>
                </div>
            </div>
        </div>
        <div id="historyModal" class="modal">
            <div class="modal-content">
                <span class="close-button" onclick="closeHistoryModal()">&times;</span>
                <h3 id="modalTitle"></h3>
            <div class="graph-controls">
                <button id="deleteMetricBtn" onclick="handleDeleteMetric()" aria-label="מחק מדד מותאם">מחק מדד</button>
                <button onclick="openProjectSelectionForComparison()">השווה לפרויקט אחר</button>
            </div>
            <div class="modal-graph-container">
                <svg class="modal-graph-svg" id="modalGraphSvg"></svg>
            </div>
            <ul id="historyList" class="history-list"></ul>
        </div>
    </div>
    <div id="projectManagementModal" class="modal">
        <div class="modal-content project-modal-content">
            <span class="close-button" onclick="closeProjectManagementModal()">&times;</span>
            <h3>ניהול פרויקטים</h3>
            <div class="project-filter">
                <label for="projectYearFilter">סינון לפי שנה:</label>
                <select id="projectYearFilter">
                    <option value="all">כל השנים</option>
                </select>
            </div>
            <ul id="projectList" class="project-list"></ul>
            <button class="add-project-btn" onclick="addNewProject()">+ כרטיסייה חדשה</button>
        </div>
    </div>
    <div id="financeModal" class="modal">
        <div class="modal-content finance-modal-content">
            <span class="close-button" onclick="closeFinanceModal()">&times;</span>
            <h3>ניהול כספים בפרויקט הנוכחי</h3>
            <div class="finance-input-group">
                <label for="financeAmount">סכום:</label>
                <input type="number" id="financeAmount" placeholder="הכנס סכום">
                <label for="financeNotes">הערות:</label>
                <textarea id="financeNotes" placeholder="הכנס הערות (אופציונלי)" rows="3"></textarea>
                <div class="finance-input-buttons">
                    <button class="add-income-btn" onclick="addFinanceEntry('income')">הוסף הכנסה</button>
                    <button class="add-expense-btn" onclick="addFinanceEntry('expense')">הוסף הוצאה</button>
                </div>
            </div>
            <ul id="financeList" class="finance-list"></ul>
            <div class="finance-balance-total">
                יתרה נוכחית: <span id="currentBalance">0</span>
            </div>
        </div>
    </div>
    <div id="currentProjectFinanceReportModal" class="modal current-project-finance-report-modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeCurrentProjectFinanceReportModal()">&times;</span>
            <h3>דוח כספי - פרויקט נוכחי</h3>
            <div class="current-project-finance-report-summary">
                <div class="total-income">סה"כ הכנסות: <span id="currentProjectTotalIncome">0</span></div>
                <div class="total-expense">סה"כ הוצאות: <span id="currentProjectTotalExpense">0</span></div>
                <div class="total-balance">יתרה נוכחית: <span id="currentProjectTotalBalance">0</span></div>
            </div>
            <table class="current-project-finance-report-table" id="currentProjectFinanceReportTable">
                <thead>
                    <tr>
                        <th>תאריך</th>
                        <th>סוג</th>
                        <th>סכום</th>
                        <th>הערות</th>
                    </tr>
                </thead>
                <tbody id="currentProjectFinanceReportTableBody"></tbody>
            </table>
            <button class="download-pdf-btn" onclick="downloadCurrentProjectFinancePDF()">הורד כ-PDF</button>
        </div>
    </div>
    <div id="globalFinanceReportModal" class="modal">
        <div class="modal-content global-finance-modal-content">
            <span class="close-button" onclick="closeGlobalFinanceReportModal()">&times;</span>
            <h3>דוח כספי כולל (כל הפרויקטים)</h3>
            <div class="global-finance-report-summary">
                <div class="total-income">סה"כ הכנסות: <span id="globalTotalIncome">0</span></div>
                <div class="total-expense">סה"כ הוצאות: <span id="globalTotalExpense">0</span></div>
                <div class="total-balance">יתרה כוללת: <span id="globalTotalBalance">0</span></div>
            </div>
            <div id="globalFinanceProjectsDetails"></div>
            <button class="download-pdf-btn" onclick="downloadGlobalFinancePDF()">הורד כ-PDF</button>
        </div>
    </div>
    <div id="financeYearlyModal" class="modal">
        <div class="modal-content finance-yearly-modal-content">
            <span class="close-button" onclick="closeFinanceYearlyModal()">&times;</span>
            <h3>דוח כספי לפי שנה</h3>
            <div class="year-selector">
                <label for="yearSelect">בחר שנה:</label>
                <select id="yearSelect"></select>
                <button onclick="generateYearlyReport()">צור דוח</button>
            </div>
            <div id="yearlyReportContent" style="display:none;">
                <div class="finance-yearly-report-summary">
                    <div class="total-income">סה"כ הכנסות: <span id="yearlyTotalIncome">0</span></div>
                    <div class="total-expense">סה"כ הוצאות: <span id="yearlyTotalExpense">0</span></div>
                    <div class="total-balance">יתרה נוכחית: <span id="yearlyTotalBalance">0</span></div>
                </div>
                <div id="yearlyFinanceProjectsDetails"></div>
                <button class="download-pdf-btn" onclick="downloadYearlyFinancePDF()">הורד כ-PDF</button>
            </div>
        </div>
    </div>
    <div id="inboxModal" class="reminders-modal">
        <div class="reminders-modal-content">
            <span class="close-button" onclick="closeInboxModal()">&times;</span>
            <h3>תיבת דואר</h3>
            <ul id="inboxList" class="reminders-list"></ul>
        </div>
    </div>
    <div id="remindersModal" class="reminders-modal">
        <div class="reminders-modal-content">
            <span class="close-button" onclick="closeRemindersModal()">&times;</span>
            <h3>תזכורות</h3>
            <div class="add-reminder-form">
                <input type="text" id="reminderText" placeholder="טקסט התזכורת">
                <input type="datetime-local" id="reminderDateTime">
                <label><input type="checkbox" id="reminderPopup"> הצג כהודעה קופצת בדפדפן</label>
                <div class="sound-selection">
                    <label for="reminderSound">צליל תזכורת:</label>
                    <select id="reminderSound">
                        <option value="none">ללא צליל</option>
                        <option value="alarm1" selected>שעון מעורר 1</option>
                        <option value="alarm2">שעון מעורר 2</option>
                        <option value="bell">פעמון</option>
                        <option value="chime">צלצול עדין</option>
                    </select>
                    <button type="button" onclick="previewReminderSound()" class="preview-sound-btn">
                        <i class="fas fa-volume-up"></i>
                    </button>
                </div>
                <div class="image-upload-section">
                    <label for="reminderImageUpload">
                        <i class="fas fa-image"></i> העלה תמונה (אופציונלי):
                    </label>
                    <div class="image-upload-buttons">
                        <input type="file" id="reminderImageUpload" accept="image/*" style="display:none;" onchange="handleReminderImageSelect(event)">
                        <button type="button" onclick="document.getElementById('reminderImageUpload').click()" class="image-upload-btn">
                            <i class="fas fa-folder-open"></i> בחר קובץ
                        </button>
                        <button type="button" onclick="openCameraForReminder()" class="camera-btn">
                            <i class="fas fa-camera"></i> צלם
                        </button>
                    </div>
                    <div id="reminderImagePreview" class="image-preview" style="display:none;">
                        <img id="reminderPreviewImg" src="" alt="תצוגה מקדימה">
                        <button type="button" onclick="removeReminderImage()" class="remove-image-btn">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
                <button id="addReminderBtn" onclick="addReminder()">הוסף תזכורת</button>
            </div>
            <ul id="remindersList" class="reminders-list"></ul>
        </div>
    </div>
    <div id="instructionsModal" class="modal">
        <div class="modal-content instructions-modal-content">
            <span class="close-button" onclick="closeInstructionsModal()">&times;</span>
            <h3>הוראות שימוש באתר</h3>
            <p>ברוכים הבאים למערכת ניטור וניהול יין! כאן תוכלו לעקוב אחר תהליך ייצור היין שלכם שלב אחר שלב, לנהל פרויקטים שונים, לעקוב אחר הוצאות והכנסות, ולצפות בדוחות מפורטים.</p>
            <h4>תכונות עיקריות:</h4>
            <ul>
                <li>**ניהול פרויקטים:** צרו פרויקטים שונים (לדוגמה, "קברנה 2024", "מרלו 2023") ונהלו את הנתונים עבור כל אחד בנפרד.</li>
                <li>**שלבי ייצור:** כל פרויקט מחולק לשלבי ייצור מוגדרים מראש, שלכל אחד מהם יש מדדים רלוונטיים.</li>
                <li>**הזנת מדדים:** הזינו בקלות נתונים בשדות המתאימים ולחצו "עדכן".</li>
                <li>**צפייה בהיסטוריה:** לחצו על כל שורת מדד או פריט בלוח המחוונים כדי לראות את ההיסטוריה המלאה שלו עם גרף.</li>
                <li>**עריכת שם פרויקט:** לחצו על שם הפרויקט (ליד "מערכת ניטור נתונים") כדי לערוך אותו.</li>
                <li>**כרטיסיית פרטי פרויקט:** בצד שמאל למעלה, לחצו על כל פרט (שם יין, תאריך בציר וכו') כדי לערוך אותו. ניתן גם להוסיף שדות מותאמים אישית.</li>
            </ul>
            <h4>כיצד להשתמש:</h4>
            <ul>
                <li>**תפריט המבורגר (מימין למעלה):** לחצו על האייקון (שלוש קווים) כדי לפתוח את תפריט הניווט.</li>
                <li>**מעבר בין שלבים:** השתמשו בכפתורי השלבים (לדוגמה, "בציר") כדי לעבור בין שלבי הייצור של הפרויקט הנוכחי.</li>
                <li>**ציר זמן:** צפו בכל המדידות של הפרויקט הנוכחי על גבי ציר זמן כרונולוגי אחד.</li>
                <li>**ניהול כספים:** עקבו אחר הכנסות והוצאות לכל פרויקט, וצפו ביתרה הנוכחית. ניתן לסנן לפי סוג תנועה ותאריך.</li>
                <li>**דוח כספי:** קבלו סיכום פיננסי רק לפרויקט הנוכחי.</li>
                <li>**דוח כספי כולל:** קבלו סיכום פיננסי משולב מכל הפרויקטים שלכם.</li>
                <li>**תזכורות:** הוסיפו תזכורות עם טקסט ותאריך/שעה, ותקבלו הודעה בדפדפן כשהזמן מגיע.</li>
                <li>**תיבת דואר:** צפו בתזכורות שהתקבלו.</li>
                <li>**מצב כהה:** עברו למצב תצוגה כהה לנוחות מירבית.</li>
            </ul>
        </div>
    </div>
    <div id="timelineModal" class="modal">
        <div class="modal-content timeline-modal-content">
            <span class="close-button" onclick="closeTimelineModal()">&times;</span>
            <h3>ציר זמן - כל המדידות</h3>
            <div class="timeline-container" id="timelineContainer"></div>
            <button class="download-pdf-btn" onclick="downloadTimelinePDF()">הורד כ-PDF</button>
        </div>
    </div>
    <div id="datePickerModal" class="modal">
        <div class="modal-content date-picker-modal-content">
            <span class="close-button" onclick="closeDatePickerModal()">&times;</span>
            <div class="date-picker-header">
                <button id="prevMonthBtn"> &#8249; </button>
                <span id="currentMonthYear"></span>
                <button id="nextMonthBtn"> &#8250; </button>
            </div>
            <div class="date-picker-grid" id="datePickerGrid">
                <div class="date-picker-day header">א</div>
                <div class="date-picker-day header">ב</div>
                <div class="date-picker-day header">ג</div>
                <div class="date-picker-day header">ד</div>
                <div class="date-picker-day header">ה</div>
                <div class="date-picker-day header">ו</div>
                <div class="date-picker-day header">ש</div>
            </div>
        </div>
    </div>
        <div id="projectSelectionModal" class="modal">
            <div class="modal-content project-modal-content">
                <span class="close-button" onclick="closeProjectSelectionModal()">&times;</span>
                <h3>בחר פרויקט להשוואה</h3>
                <ul id="comparisonProjectList" class="project-list"></ul>
            </div>
        </div>
        <div id="accessControlModal" class="modal">
            <div class="modal-content access-modal-content">
                <span class="close-button" onclick="closeAccessControlModal()">&times;</span>
                <h3><i class="fas fa-users-cog"></i> ניהול גישה למערכת</h3>
                
                <!-- Share Access Content (Simplified - No Tabs) -->
                <div class="access-content">
                    <!-- Add New User Section -->
                    <div class="access-section add-user-section">
                        <h4><i class="fas fa-user-plus"></i> הוסף משתמש חדש</h4>
                        <p class="section-description">הזן את כתובת המייל של המשתמש והגדר הרשאות גישה לפרויקטים</p>
                        
                        <div class="form-group">
                            <label for="newUserEmail"><i class="fas fa-envelope"></i> כתובת מייל:</label>
                            <input type="email" id="newUserEmail" placeholder="user@example.com" required>
                        </div>
                        
                        <div class="form-group">
                            <label for="userProjectAccess"><i class="fas fa-folder-open"></i> גישה לפרויקטים:</label>
                            <select id="userProjectAccess">
                                <option value="all">כל הפרויקטים</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label><i class="fas fa-key"></i> הרשאות:</label>
                            <div class="permissions-container">
                                <div class="permission-option">
                                    <input type="radio" id="permView" name="userPermission" value="view" checked>
                                    <label for="permView">
                                        <i class="fas fa-eye"></i>
                                        <span class="perm-title">צפייה בלבד</span>
                                        <span class="perm-desc">המשתמש יוכל לצפות בנתונים בלבד</span>
                                    </label>
                                </div>
                                <div class="permission-option">
                                    <input type="radio" id="permEdit" name="userPermission" value="edit">
                                    <label for="permEdit">
                                        <i class="fas fa-edit"></i>
                                        <span class="perm-title">עריכה</span>
                                        <span class="perm-desc">המשתמש יוכל לצפות ולערוך נתונים</span>
                                    </label>
                                </div>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label class="checkbox-label">
                                <input type="checkbox" id="userFinanceAccess">
                                <i class="fas fa-dollar-sign"></i> גישה לניהול כספים
                            </label>
                        </div>
                        
                        <button class="btn-primary" onclick="grantUserAccess()">
                            <i class="fas fa-user-check"></i> הענק גישה
                        </button>
                    </div>
                    
                    <hr class="section-divider">
                    
                    <!-- Active Users Section -->
                    <div class="access-section active-users-section">
                        <h4><i class="fas fa-users"></i> משתמשים עם גישה פעילה</h4>
                        <div class="users-list-container">
                            <ul id="activeUsersList" class="active-users-list"></ul>
                            <div id="noUsersMessage" class="no-users-message" style="display:none;">
                                <i class="fas fa-info-circle"></i>
                                <p>אין משתמשים עם גישה כרגע</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="accountSwitchModal" class="modal">
            <div class="modal-content access-modal-content">
                <span class="close-button" onclick="closeAccountSwitchModal()">&times;</span>
                <h3><i class="fas fa-users"></i> חיבור חשבונות</h3>
                
                <div class="access-content">
                    <!-- Current Account Section -->
                    <div class="access-section">
                        <h4><i class="fas fa-user"></i> החשבון הנוכחי שלי</h4>
                        <div id="currentAccountDisplay" class="current-account-info">
                            <p>טוען...</p>
                        </div>
                    </div>
                    
                    <hr class="section-divider">
                    
                    <!-- Connect Account Section -->
                    <div class="access-section">
                        <h4><i class="fas fa-link"></i> חבר חשבון נוסף</h4>
                        <p class="section-description">הזן את כתובת המייל של החשבון שאליו יש לך הרשאת גישה</p>
                        
                        <div class="form-group">
                            <label for="connectAccountEmail"><i class="fas fa-envelope"></i> כתובת מייל:</label>
                            <input type="email" id="connectAccountEmail" placeholder="user@example.com" required>
                        </div>
                        
                        <button class="btn-primary" onclick="connectToAccount()">
                            <i class="fas fa-link"></i> התחבר לחשבון
                        </button>
                    </div>
                    
                    <hr class="section-divider">
                    
                    <!-- Connected Accounts Section -->
                    <div class="access-section">
                        <h4><i class="fas fa-exchange-alt"></i> חשבונות מחוברים</h4>
                        <div class="connected-accounts-container">
                            <ul id="connectedAccountsList" class="connected-accounts-list"></ul>
                            <div id="noConnectedAccountsMessage" class="no-users-message" style="display:none;">
                                <i class="fas fa-info-circle"></i>
                                <p>אין חשבונות מחוברים</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="confirmationModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="confirmationTitle" aria-describedby="confirmationMessage" tabindex="-1">
            <div class="modal-content confirmation-modal-content">
                <span class="close-button" onclick="document.getElementById('confirmNoBtn').click()">&times;</span>
                <h3 id="confirmationTitle">אישור</h3>
                <p id="confirmationMessage">האם אתה בטוח?</p>
                <div class="modal-actions">
                    <button id="confirmYesBtn" class="btn-danger">כן</button>
                    <button id="confirmNoBtn" class="btn-secondary">לא</button>
                </div>
            </div>
        </div>
    <script>
        const stagesConfig = {
            'wineDetails': {
                name: 'פרטי יין',
                longName: 'פרטי יין',
                metrics: {
                    'wineName': { name: 'שם היין', type: 'text', placeholder: 'קברנה יקב הידון 2024' },
                    'vintageYear': { name: 'שנה', type: 'number', step: 1, precision: 0, placeholder: '2024' },
                    'grapeVariety': { name: 'זן הענבים', type: 'select', options: ['קברנה סוביניון', 'מרלו', 'שיראז', 'שרדונה', 'סוביניון בלאן', 'פינו נואר', 'גרנאש', 'זינפנדל','ריזלינג', 'גוורצטרמינר', 'שן בלאן', 'ויונייה', 'ברברה', 'סנג\'ובזה', 'נביולו', 'טמפרניו', 'אחר'], placeholder: 'בחר זן' },
                    'vineyardSource': { name: 'מקור הענבים', type: 'text', placeholder: 'כרם גליל עליון' },
                    'harvestDate': { name: 'תאריך בציר', type: 'date', placeholder: 'בחר תאריך' },
                    'generalNotes': { name: 'הערות נוספות', type: 'text', placeholder: 'יין בעל פוטנציאל יישון' }
                },
                customMetrics: {}
            },
            'stage1': {
                name: 'בציר',
                longName: 'בציר',
                emoji: '🟢',
                metrics: {
                    'brix': { name: 'בריקס', type: 'number', step: 0.1, precision: 1, placeholder: '22.5' },
                    'ph': { name: 'pH', type: 'number', step: 0.01, precision: 2, placeholder: '3.5' },
                    'ta': { name: 'חומצה כוללת', type: 'number', step: 0.01, precision: 2, placeholder: '6.8' },
                    'grapeTemp': { name: 'טמפרטורת ענבים', type: 'number', step: 0.1, precision: 1, placeholder: '25.0' },
                },
                summaryMetrics: ['brix', 'ph', 'ta'],
                customMetrics: {}
            },
            'stage2': {
                name: 'ריסוק',
                longName: 'ריסוק והכנה לתסיסה',
                emoji: '🍇',
                metrics: {
                    'so2Added': { name: 'SO₂', type: 'number', step: 0.1, precision: 1, placeholder: '50' },
                    'enzymesAdded': { name: 'אנזימים', type: 'number', step: 0.1, precision: 1, placeholder: '0.8' },
                    'mixTemp': { name: 'טמפרטורת תערובת', type: 'number', step: 0.1, precision: 1, placeholder: '18.0' },
                    'skinLiquidRatio': { name: 'יחס קליפות/נוזלים', type: 'text', placeholder: '1:3' },
                    'brixStart': { name: 'בריקס התחלה', type: 'number', step: 0.1, precision: 1, placeholder: '23.0' },
                    'fermentationSync': { name: 'מצב סנכרון', type: 'text', placeholder: 'אושר' }
                },
                summaryMetrics: ['so2Added', 'mixTemp', 'brixStart'],
                customMetrics: {}
            },
            'stage3': {
                name: 'תסיסה אלכוהולית',
                longName: 'תסיסה אלכוהולית',
                emoji: '🍷',
                metrics: {
                    'brixDaily': { name: 'בריקס יומי', type: 'number', step: 0.1, precision: 1, placeholder: '15.0' },
                    'phFerment': { name: 'pH', type: 'number', step: 0.01, precision: 2, placeholder: '3.65' },
                    'fermentTemp': { name: 'טמפרטורת תסיסה', type: 'number', step: 0.1, precision: 1, placeholder: '26.5' },
                    'yeastAdded': { name: 'שמרים', type: 'text', placeholder: 'EC-1118' },
                    'yeastFoodAdded': { name: 'מזון שמרים', type: 'text', placeholder: '2 גרם/ליטר' },
                    'density': { name: 'צפיפות (SG)', type: 'number', step: 0.001, precision: 3, placeholder: '1.050' },
                    'fermentRate': { name: 'קצב תסיסה', type: 'text', placeholder: 'יציב / מהיר' },
                    'fermentStartDate': { name: 'תאריך התחלה', type: 'date', placeholder: '20/08/2024' },
                    'fermentEndDate': { name: 'תאריך סיום', type: 'date', placeholder: '30/08/2024' }
                },
                summaryMetrics: ['brixDaily', 'phFerment', 'fermentTemp', 'density'],
                customMetrics: {}
            },
            'stage4': {
                name: 'תסיסה מלולקטית',
                longName: 'תסיסה מלולקטית',
                emoji: '🔁',
                metrics: {
                    'phMLF': { name: 'pH', type: 'number', step: 0.01, precision: 2, placeholder: '3.80' },
                    'malicAcid': { name: 'חומצה מלית', type: 'text', placeholder: 'ירידה קלה' },
                    'roomTempMLF': { name: 'טמפרטורת חדר', type: 'number', step: 0.1, precision: 1, placeholder: '20.0' },
                    'mlfStatus': { name: 'מצב תסיסה', type: 'text', placeholder: 'באמצע' },
                    'bacteriaAdded': { name: 'חיידקים', type: 'text', placeholder: 'Oenococcus oeni' },
                    'tasteNotesMLF': { name: 'טעמים (רישום ידני)', type: 'text', placeholder: 'חמאתיות עדינה' }
                },
                summaryMetrics: ['phMLF', 'roomTempMLF', 'mlfStatus'],
                customMetrics: {}
            },
            'stage5': {
                name: 'יישון',
                longName: 'יישון',
                emoji: '🛢',
                metrics: {
                    'containerType': { name: 'סוג מיכל', type: 'text', placeholder: 'חבית עץ אלון צרפתי' },
                    'agingTime': { name: 'זמן יישון (ימים)', type: 'number', step: 1, precision: 0, placeholder: '180' },
                    'agingRoomTemp': { name: 'טמפרטורת חדר יישון', type: 'number', step: 0.1, precision: 1, placeholder: '15.0' },
                    'so2Control': { name: 'פקדי חמצון (SO₂)', type: 'text', placeholder: 'בדיקה חודשית' },
                    'tasteTextureNotes': { name: 'טעמים ומרקם', type: 'text', placeholder: 'עיגול טעמים, טאנינים רכים' },
                    'rackingDate': { name: 'תאריך שקיעה', type: 'date', placeholder: '01/03/2025' },
                    'rackingFrequency': { name: 'תדירות שקיעות', type: 'text', placeholder: 'כל חודשיים' }
                },
                summaryMetrics: ['containerType', 'agingTime', 'agingRoomTemp'],
                customMetrics: {}
            },
            'stage6': {
                name: 'הכנה לבקבוק',
                longName: 'הכנה לבקבוק',
                emoji: '🧪',
                metrics: {
                    'phFinal': { name: 'pH סופי', type: 'number', step: 0.01, precision: 2, placeholder: '3.75' },
                    'clarity': { name: 'צלילות', type: 'text', placeholder: 'צלול לגמרי' },
                    'bottlingDate': { name: 'תאריך בקבוק', type: 'date', placeholder: '15/05/2025' },
                    'bottleCount': { name: 'כמות בקבוקים', type: 'number', step: 1, precision: 0, placeholder: '750' },
                    'so2AddedBottle': { name: 'תוספת SO₂', type: 'number', step: 0.1, precision: 1, placeholder: '30' },
                    'alcoholLevel': { name: 'רמת אלכוהול (%)', type: 'number', step: 0.1, precision: 1, placeholder: '14.2' },
                    'batchNumber': { name: 'מספר אצווה / תווית', type: 'text', placeholder: 'יין אדום 2024A' }
                },
                summaryMetrics: ['phFinal', 'bottleCount', 'alcoholLevel'],
                customMetrics: {}
            },
        };
        // Expose stagesConfig globally for the stage-nav-fix module
        window.stagesConfig = stagesConfig;
        let projects = loadProjects();
        let currentProjectId = localStorage.getItem('currentProjectId') || Object.keys(projects)[0];
        let currentStageId = localStorage.getItem('currentStageId') || 'stage1';
        if (!currentProjectId || !projects[currentProjectId]) {
            currentProjectId = 'default_project';
            if (!projects[currentProjectId]) {
                projects[currentProjectId] = createNewProjectData('פרויקט ראשי');
            }
            localStorage.setItem('currentProjectId', currentProjectId);
        }
        if (!stagesConfig[currentStageId] || currentStageId === 'wineDetails') {
            currentStageId = 'stage1';
            localStorage.setItem('currentStageId', currentStageId);
        }
        const hamburgerBtn = document.getElementById('hamburgerBtn');
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebarOverlay');
        const darkModeToggle = document.getElementById('darkModeToggle');
        const projectYearFilter = document.getElementById('projectYearFilter');
        const yearSelect = document.getElementById('yearSelect');
        const currentProjectNameDisplay = document.getElementById('currentProjectName');
        const editProjectNameInput = document.getElementById('editProjectNameInput');
        const projectDetailsCard = document.getElementById('projectDetailsCard');
        const cardFab = document.getElementById('cardFab');
        const stageNavContainer = document.getElementById('stageNavContainer');
        const stageOverviewContainer = document.getElementById('stageOverviewContainer');
        const stepCardsGrid = document.getElementById('stepCardsGrid');
        const currentStageContent = document.getElementById('currentStageContent');
        const currentStageInputSection = document.getElementById('currentStageInputSection');
        const fixedDashboardSection = document.getElementById('fixedDashboardSection');
        const fixedDashboardStageName = document.getElementById('fixedDashboardStageName');
        const fixedDashboardGrid = document.getElementById('fixedDashboardGrid');
        const historyModal = document.getElementById('historyModal');
        const modalTitle = document.getElementById('modalTitle');
        const historyList = document.getElementById('historyList');
        const modalGraphSvg = document.getElementById('modalGraphSvg');
        const projectManagementModal = document.getElementById('projectManagementModal');
        const projectList = document.getElementById('projectList');
        const financeModal = document.getElementById('financeModal');
        const financeAmountInput = document.getElementById('financeAmount');
        const financeNotesInput = document.getElementById('financeNotes');
        const financeList = document.getElementById('financeList');
        const currentBalanceDisplay = document.getElementById('currentBalance');
        const financeEditModal = document.getElementById('financeEditModal');
        const financeEditAmountInput = document.getElementById('financeEditAmount');
        const financeEditNotesInput = document.getElementById('financeEditNotes');
        const currentProjectFinanceReportModal = document.getElementById('currentProjectFinanceReportModal');
        const currentProjectTotalIncomeDisplay = document.getElementById('currentProjectTotalIncome');
        const currentProjectTotalExpenseDisplay = document.getElementById('currentProjectTotalExpense');
        const currentProjectTotalBalanceDisplay = document.getElementById('currentProjectTotalBalance');
        const currentProjectFinanceReportTableBody = document.getElementById('currentProjectFinanceReportTableBody');
        const globalFinanceReportModal = document.getElementById('globalFinanceReportModal');
        const globalTotalIncomeDisplay = document.getElementById('globalTotalIncome');
        const globalTotalExpenseDisplay = document.getElementById('globalTotalExpense');
        const globalTotalBalanceDisplay = document.getElementById('globalTotalBalance');
        const globalFinanceProjectsDetails = document.getElementById('globalFinanceProjectsDetails');
        const financeYearlyModal = document.getElementById('financeYearlyModal');
        const yearlyReportContent = document.getElementById('yearlyReportContent');
        const yearlyTotalIncomeDisplay = document.getElementById('yearlyTotalIncome');
        const yearlyTotalExpenseDisplay = document.getElementById('yearlyTotalExpense');
        const yearlyTotalBalanceDisplay = document.getElementById('yearlyTotalBalance');
        const yearlyFinanceProjectsDetails = document.getElementById('yearlyFinanceProjectsDetails');
        const inboxModal = document.getElementById('inboxModal');
        const inboxList = document.getElementById('inboxList');
        const remindersModal = document.getElementById('remindersModal');
        const reminderTextInput = document.getElementById('reminderText');
        const reminderDateTimeInput = document.getElementById('reminderDateTime');
        const reminderPopupInput = document.getElementById('reminderPopup');
        const remindersList = document.getElementById('remindersList');
        const instructionsModal = document.getElementById('instructionsModal');
        const timelineModal = document.getElementById('timelineModal');
        const timelineContainer = document.getElementById('timelineContainer');
        const datePickerModal = document.getElementById('datePickerModal');
        const datePickerGrid = document.getElementById('datePickerGrid');
        const currentMonthYearDisplay = document.getElementById('currentMonthYear');
        let datePickerCurrentMonth = new Date().getMonth();
        let datePickerCurrentYear = new Date().getFullYear();
        let datePickerCallback = null;
        const projectSelectionModal = document.getElementById('projectSelectionModal');
        const comparisonProjectList = document.getElementById('comparisonProjectList');
        const newProjectModal = document.getElementById('newProjectModal');
        const newProjectNameInput = document.getElementById('newProjectNameInput');
        const customPropertyModal = document.getElementById('customPropertyModal');
        const customPropertyNameInput = document.getElementById('customPropertyNameInput');
        const deleteMetricBtn = document.getElementById('deleteMetricBtn');
        
        // Image upload variables
        let selectedReminderImage = null;
        let selectedReminderImageFile = null;
        const accessControlModal = document.getElementById('accessControlModal');
        const inviteEmailInput = document.getElementById('inviteEmailInput');
        const inviteProjectSelect = document.getElementById('inviteProjectSelect');
        const inviteAllowEdit = document.getElementById('inviteAllowEdit');
        const inviteFinanceAccess = document.getElementById('inviteFinanceAccess');
        const inviteLinkOutput = document.getElementById('inviteLinkOutput');
        const inviteList = document.getElementById('inviteList');
        const sharedAccessNotice = document.getElementById('sharedAccessNotice');
        let currentMetricTypeForModal = { sectionId: '', metricId: '' };
        let currentEditableDetailElement = null;
        let graphComparisonMode = null;
        let comparisonProjectId = null;
        let inbox = JSON.parse(localStorage.getItem('inbox')) || [];
        let reminders = JSON.parse(localStorage.getItem('reminders')) || [];
        // Card transition duration - set via JS at line 4984: projectDetailsCard.style.transition = 'left 0.3s ease'
        // Used to time the delayed visibility hide after slide-out animation completes
        const CARD_TRANSITION_DURATION = 300; // milliseconds
        let cardHideTimeout = null; // Track timeout to prevent race conditions
        // משתני הזזה לכרטיסיה
        let isDragging = false;
        let startX = 0;
        let currentX = 0;
        let cardOpen = false; // מצב הכרטיסיה: פתוח או סגור
        let editingFinanceEntryId = null;
        let sharedAccessContext = { active: false, inviteId: null, ownerUid: null, allowEdit: false, allowFinance: false, allowedProjectId: null };
        if (newProjectNameInput) {
            newProjectNameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    confirmAddNewProject();
                }
            });
        }
        if (customPropertyNameInput) {
            customPropertyNameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    confirmAddCustomProperty();
                }
            });
        }
        if (financeEditAmountInput) {
            financeEditAmountInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    saveFinanceEdit();
                }
            });
        }
        if (financeEditNotesInput) {
            financeEditNotesInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                    saveFinanceEdit();
                }
            });
        }
        function isProjectAllowed(projectId) {
            if (!sharedAccessContext.active) return true;
            if (!sharedAccessContext.allowedProjectId) return true;
            return sharedAccessContext.allowedProjectId === projectId;
        }
        function ensureProjectAccess(projectId) {
            if (!isProjectAllowed(projectId)) {
                alert('אין לך הרשאה לפרויקט זה לפי ההזמנה.');
                return false;
            }
            return true;
        }
        function ensureEditPermission(projectId = currentProjectId) {
            if (!ensureProjectAccess(projectId)) return false;
            if (sharedAccessContext.active && !sharedAccessContext.allowEdit) {
                alert('גישה זו היא לצפייה בלבד.');
                return false;
            }
            return true;
        }
        function ensureFinancePermission(projectId = currentProjectId) {
            if (!ensureProjectAccess(projectId)) return false;
            if (sharedAccessContext.active && !sharedAccessContext.allowFinance) {
                alert('אין לך הרשאת כספים בהזמנה זו.');
                return false;
            }
            return true;
        }
        function updateSharedAccessNotice() {
            if (!sharedAccessNotice) return;
            document.body.classList.toggle('view-only', sharedAccessContext.active && !sharedAccessContext.allowEdit && !sharedAccessContext.allowFinance);
            if (sharedAccessContext.active) {
                sharedAccessNotice.style.display = 'block';
                sharedAccessNotice.classList.toggle('view-only', !sharedAccessContext.allowEdit);
                const scopeText = sharedAccessContext.allowedProjectId ? 'פרויקט ספציפי' : 'כל הפרויקטים';
                const mode = sharedAccessContext.allowEdit ? 'עריכה' : 'צפייה בלבד';
                const finance = sharedAccessContext.allowFinance ? 'כולל כספים' : 'ללא גישה לכספים';
                sharedAccessNotice.textContent = `גישה משותפת (${scopeText}) - ${mode}, ${finance}`;
            } else {
                sharedAccessNotice.style.display = 'none';
            }
        }
        function populateYearSelects() {
            const currentYear = new Date().getFullYear();
            for (let year = 2020; year <= 2100; year++) {
                const option1 = document.createElement('option');
                option1.value = year;
                option1.textContent = year;
                projectYearFilter.appendChild(option1);
                const option2 = document.createElement('option');
                option2.value = year;
                option2.textContent = year;
                yearSelect.appendChild(option2);
            }
            projectYearFilter.value = 'all';
            yearSelect.value = currentYear;
        }
        function zoomIn() {
            const root = document.documentElement;
            const currentSize = parseInt(getComputedStyle(root).getPropertyValue('--font-size-base'));
            root.style.setProperty('--font-size-base', (currentSize + 2) + 'px');
        }
        function zoomOut() {
            const root = document.documentElement;
            const currentSize = parseInt(getComputedStyle(root).getPropertyValue('--font-size-base'));
            if (currentSize > 10) {
                root.style.setProperty('--font-size-base', (currentSize - 2) + 'px');
            }
        }
        function toggleGraphComparison(mode) {
            graphComparisonMode = mode;
            const metricDisplayName = stagesConfig[currentMetricTypeForModal.sectionId]?.metrics[currentMetricTypeForModal.metricId]?.name || 'מדד';
            openHistoryModal(currentMetricTypeForModal.sectionId, currentMetricTypeForModal.metricId, metricDisplayName);
        }
        function openProjectSelectionForComparison() {
            closeSidebar();
            document.querySelector('.container').style.display = 'none';
            document.querySelector('.top-section-wrapper').style.display = 'none';
            fixedDashboardSection.style.display = 'none';
            projectSelectionModal.style.display = 'flex';
            renderComparisonProjectList();
        }
        function closeProjectSelectionModal() {
            projectSelectionModal.style.display = 'none';
            showMainContent();
        }
        function renderComparisonProjectList() {
            comparisonProjectList.innerHTML = '';
            Object.keys(projects).forEach(projectId => {
                if (projectId !== currentProjectId && !projects[projectId].isClosed) {
                    const listItem = document.createElement('li');
                    listItem.textContent = projects[projectId].name;
                    listItem.setAttribute('data-project-id', projectId);
                    listItem.onclick = () => selectComparisonProject(projectId);
                    comparisonProjectList.appendChild(listItem);
                }
            });
        }
        function selectComparisonProject(projectId) {
            comparisonProjectId = projectId;
            closeProjectSelectionModal();
            const metricDisplayName = stagesConfig[currentMetricTypeForModal.sectionId]?.metrics[currentMetricTypeForModal.metricId]?.name || 'מדד';
            openHistoryModal(currentMetricTypeForModal.sectionId, currentMetricTypeForModal.metricId, metricDisplayName);
        }
        
        // Sound definitions using Web Audio API
        const reminderSounds = {
            none: null,
            alarm1: { frequency: 800, pattern: [300, 150, 300, 150, 300, 450, 300, 150] }, // Made longer
            alarm2: { frequency: 600, pattern: [250, 150, 250, 150, 600, 300, 250, 150] }, // Made longer
            bell: { frequency: 1000, pattern: [450, 300, 450, 600, 450, 300] }, // Made longer
            chime: { frequency: 1200, pattern: [150, 75, 150, 75, 150, 300, 150, 75] } // Made longer
        };
        
        let audioContext = null;
        
        function playReminderSound(soundType) {
            if (soundType === 'none' || !reminderSounds[soundType]) return;
            
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                const sound = reminderSounds[soundType];
                let currentTime = audioContext.currentTime;
                
                sound.pattern.forEach((duration, index) => {
                    if (index % 2 === 0) { // Play on even indices
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.frequency.value = sound.frequency + (index * 50);
                        oscillator.type = 'sine';
                        
                        gainNode.gain.setValueAtTime(0.3, currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + duration / 1000);
                        
                        oscillator.start(currentTime);
                        oscillator.stop(currentTime + duration / 1000);
                    }
                    currentTime += duration / 1000;
                });
            } catch (e) {
                console.error('Error playing sound:', e);
            }
        }
        
        function previewReminderSound() {
            const soundSelect = document.getElementById('reminderSound');
            if (soundSelect) {
                playReminderSound(soundSelect.value);
            }
        }
        
        function showReminderPopup(text) {
            const popup = document.getElementById('reminderPopupNotification');
            const popupText = document.getElementById('reminderPopupText');
            
            if (popup && popupText) {
                popupText.textContent = text;
                popup.style.display = 'block';
                
                // Auto-hide after 10 seconds
                setTimeout(() => {
                    closeReminderPopup();
                }, 10000);
            }
        }
        
        function closeReminderPopup() {
            const popup = document.getElementById('reminderPopupNotification');
            if (popup) {
                popup.style.display = 'none';
            }
        }
        
        function updateInboxBadge() {
            const badge = document.getElementById('inboxBadge');
            if (badge) {
                const unreadCount = inbox.length;
                if (unreadCount > 0) {
                    badge.textContent = unreadCount > 99 ? '99+' : unreadCount;
                    badge.style.display = 'inline-flex';
                } else {
                    badge.style.display = 'none';
                }
            }
        }
        
        async function checkReminders() {
            const now = new Date();
            let remindersUpdated = false;
            let inboxUpdated = false;
            
            reminders.forEach(reminder => {
                const reminderTime = new Date(reminder.datetime);
                if (reminderTime <= now && !reminder.notified) {
                    reminder.notified = true;
                    remindersUpdated = true;
                    
                    // Play sound if selected
                    if (reminder.sound && reminder.sound !== 'none') {
                        playReminderSound(reminder.sound);
                    }
                    
                    // Show popup notification in app
                    showReminderPopup(reminder.text);
                    
                    // Show browser notification if enabled
                    if (reminder.popup && 'Notification' in window && Notification.permission === 'granted') {
                        new Notification('תזכורת: ' + reminder.text, {
                            icon: 'image_00b206.png',
                            body: new Date(reminder.datetime).toLocaleString('he-IL'),
                            requireInteraction: true
                        });
                    }
                    
                    inbox.push(reminder);
                    inboxUpdated = true;
                    renderInboxList();
                    updateInboxBadge();
                }
            });
            
            if (remindersUpdated) {
                localStorage.setItem('reminders', JSON.stringify(reminders));
                saveRemindersToFirestore(reminders).catch(e => console.error('Firestore reminders save error:', e));
                renderRemindersList();
            }
            
            if (inboxUpdated) {
                localStorage.setItem('inbox', JSON.stringify(inbox));
                saveInboxToFirestore(inbox).catch(e => console.error('Firestore inbox save error:', e));
            }
        }
        
        // Legacy function names for compatibility
        function syncRemindersToFirebase() { 
            saveRemindersToFirestore(reminders).catch(e => console.error('Firestore reminders save error:', e));
        }
        
        function syncInboxToFirebase() { 
            saveInboxToFirestore(inbox).catch(e => console.error('Firestore inbox save error:', e));
        }
        
        // Image upload functions for reminders
        function handleReminderImageSelect(event) {
            const file = event.target.files[0];
            if (file && file.type.startsWith('image/')) {
                selectedReminderImageFile = file;
                const reader = new FileReader();
                reader.onload = (e) => {
                    selectedReminderImage = e.target.result;
                    document.getElementById('reminderPreviewImg').src = e.target.result;
                    document.getElementById('reminderImagePreview').style.display = 'block';
                };
                reader.readAsDataURL(file);
            }
        }
        
        async function openCameraForReminder() {
            try {
                // Check if getUserMedia is supported
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    alert('המצלמה לא נתמכת בדפדפן זה');
                    return;
                }
                
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' } // Use back camera on mobile
                });
                
                // Create video element for preview
                const video = document.createElement('video');
                video.srcObject = stream;
                video.autoplay = true;
                video.style.width = '100%';
                video.style.maxWidth = '400px';
                video.style.borderRadius = '8px';
                
                // Create canvas for capturing
                const canvas = document.createElement('canvas');
                
                // Create capture button
                const captureBtn = document.createElement('button');
                captureBtn.textContent = 'צלם';
                captureBtn.style.marginTop = '10px';
                captureBtn.className = 'image-upload-btn';
                
                // Create cancel button
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'ביטול';
                cancelBtn.style.marginTop = '10px';
                cancelBtn.className = 'camera-btn';
                
                // Create modal for camera
                const cameraModal = document.createElement('div');
                cameraModal.className = 'modal';
                cameraModal.style.display = 'flex';
                cameraModal.innerHTML = `
                    <div class="modal-content" style="max-width: 500px; padding: 20px;">
                        <h3>צלם תמונה</h3>
                        <div id="cameraContainer"></div>
                        <div style="display: flex; gap: 10px; margin-top: 15px;">
                            <button id="cameraCaptureBtn" class="image-upload-btn" style="flex: 1;">
                                <i class="fas fa-camera"></i> צלם
                            </button>
                            <button id="cameraCancelBtn" class="camera-btn" style="flex: 1; background: linear-gradient(135deg, #f44336, #d32f2f);">
                                <i class="fas fa-times"></i> ביטול
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(cameraModal);
                document.getElementById('cameraContainer').appendChild(video);
                
                document.getElementById('cameraCaptureBtn').onclick = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    canvas.getContext('2d').drawImage(video, 0, 0);
                    
                    canvas.toBlob((blob) => {
                        selectedReminderImageFile = new File([blob], 'camera-photo.jpg', { type: 'image/jpeg' });
                        selectedReminderImage = canvas.toDataURL('image/jpeg');
                        document.getElementById('reminderPreviewImg').src = selectedReminderImage;
                        document.getElementById('reminderImagePreview').style.display = 'block';
                        
                        // Stop camera and close modal
                        stream.getTracks().forEach(track => track.stop());
                        document.body.removeChild(cameraModal);
                    }, 'image/jpeg');
                };
                
                document.getElementById('cameraCancelBtn').onclick = () => {
                    stream.getTracks().forEach(track => track.stop());
                    document.body.removeChild(cameraModal);
                };
                
            } catch (error) {
                console.error('Error accessing camera:', error);
                alert('שגיאה בגישה למצלמה: ' + error.message);
            }
        }
        
        function removeReminderImage() {
            selectedReminderImage = null;
            selectedReminderImageFile = null;
            document.getElementById('reminderImagePreview').style.display = 'none';
            document.getElementById('reminderImageUpload').value = '';
        }
        
        async function uploadReminderImage(reminderId) {
            if (!selectedReminderImageFile) {
                console.log('No image file selected, skipping upload');
                return null;
            }
            
            console.log('Converting image to base64 for reminder:', reminderId);
            console.log('Image file:', selectedReminderImageFile.name, selectedReminderImageFile.type, selectedReminderImageFile.size);
            
            // Convert image to base64 for local storage (no Firebase upload)
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    console.log('Image converted to base64');
                    resolve(e.target.result);
                };
                reader.onerror = (error) => {
                    console.error('Error reading image file:', error);
                    reject(new Error('שגיאה בקריאת התמונה'));
                };
                reader.readAsDataURL(selectedReminderImageFile);
            });
        }
        
        async function addReminder() {
            const text = reminderTextInput.value.trim();
            const datetime = reminderDateTimeInput.value;
            const popup = reminderPopupInput.checked;
            const soundSelect = document.getElementById('reminderSound');
            const sound = soundSelect ? soundSelect.value : 'alarm1';
            const addBtn = document.getElementById('addReminderBtn');
            
            if (text && datetime) {
                const reminderId = Date.now();
                
                // Disable button and show loading state
                if (addBtn) {
                    addBtn.disabled = true;
                    addBtn.textContent = 'שומר...';
                }
                
                try {
                    // Convert image to base64 if selected
                    let imageUrl = null;
                    if (selectedReminderImageFile) {
                        try {
                            imageUrl = await uploadReminderImage(reminderId);
                            console.log('Image converted to base64');
                        } catch (uploadError) {
                            console.error('Image conversion error:', uploadError);
                            // Continue without image if conversion fails
                            alert('שגיאה בעיבוד התמונה: ' + uploadError.message + '\nהתזכורת תישמר ללא תמונה.');
                        }
                    }
                    
                    const newReminder = { 
                        id: reminderId, 
                        text, 
                        datetime, 
                        popup, 
                        sound, 
                        notified: false,
                        imageUrl: imageUrl
                    };
                    
                    // Save to IndexedDB (prevents QuotaExceededError)
                    await saveReminderToIndexedDB(newReminder);
                    
                    // Also add to in-memory array
                    reminders.push(newReminder);
                    if (auth?.currentUser) {
                        saveRemindersToFirestore(reminders).catch(e => console.error('Firestore reminders save error:', e));
                    }
                    
                    // Backup to localStorage (metadata only, without large base64 images)
                    try {
                        const remindersCopy = reminders.map(r => ({
                            ...r,
                            // Don't store base64 in localStorage to avoid quota
                            imageUrl: r.imageUrl && r.imageUrl.startsWith('http') ? r.imageUrl : null
                        }));
                        localStorage.setItem('reminders', JSON.stringify(remindersCopy));
                    } catch (storageErr) {
                        console.warn('localStorage save failed (using IndexedDB instead):', storageErr);
                    }
                    
                    reminderTextInput.value = '';
                    reminderDateTimeInput.value = '';
                    reminderPopupInput.checked = false;
                    if (soundSelect) soundSelect.value = 'alarm1';
                    removeReminderImage();
                    renderRemindersList();
                    checkReminders();
                } catch (error) {
                    console.error('Error adding reminder:', error);
                    alert('שגיאה בשמירת התזכורת. אנא נסה שוב.');
                } finally {
                    // Re-enable button and restore text
                    if (addBtn) {
                        addBtn.disabled = false;
                        addBtn.textContent = 'הוסף תזכורת';
                    }
                }
            } else {
                alert('אנא הזן טקסט ותאריך/שעה.');
            }
        }
        function renderRemindersList() {
            remindersList.innerHTML = '';
            reminders.forEach(reminder => {
                if (!reminder.notified) {
                    const soundLabel = reminder.sound === 'none' ? 'ללא צליל' :
                                      reminder.sound === 'alarm1' ? '🔔 שעון 1' :
                                      reminder.sound === 'alarm2' ? '🔔 שעון 2' :
                                      reminder.sound === 'bell' ? '🔔 פעמון' :
                                      reminder.sound === 'chime' ? '🔔 צלצול' : '';
                    
                    const imageHtml = reminder.imageUrl ? 
                        `<img src="${reminder.imageUrl}" alt="תמונה" class="reminder-item-image" onclick="window.open('${reminder.imageUrl}', '_blank')">` : '';
                    
                    const li = document.createElement('li');
                    li.innerHTML = `
                        <div class="reminder-details">
                            <div class="text">${reminder.text}</div>
                            <div class="datetime">${new Date(reminder.datetime).toLocaleString('he-IL')} ${soundLabel}</div>
                            ${imageHtml}
                        </div>
                        <div class="reminder-actions">
                            <button onclick="deleteReminder(${reminder.id})">מחק</button>
                        </div>
                    `;
                    remindersList.appendChild(li);
                }
            });
        }
        async function deleteReminder(id) {
            reminders = reminders.filter(r => r.id !== id);
            
            // Delete from IndexedDB
            try {
                await deleteReminderFromIndexedDB(id);
            } catch (error) {
                console.error('Error deleting from IndexedDB:', error);
            }
            
            // Update localStorage backup
            try {
                const remindersCopy = reminders.map(r => ({
                    ...r,
                    imageUrl: r.imageUrl && r.imageUrl.startsWith('http') ? r.imageUrl : null
                }));
                localStorage.setItem('reminders', JSON.stringify(remindersCopy));
            } catch (storageErr) {
                console.warn('localStorage update failed:', storageErr);
            }
            
            // Sync to Firestore
            if (auth?.currentUser) {
                saveRemindersToFirestore(reminders).catch(e => console.error('Firestore reminders save error:', e));
            }
            
            renderRemindersList();
        }
        function openInboxModal() {
            closeSidebar();
            document.querySelector('.container').style.display = 'none';
            document.querySelector('.top-section-wrapper').style.display = 'none';
            fixedDashboardSection.style.display = 'none';
            inboxModal.style.display = 'flex';
            renderInboxList();
        }
        function closeInboxModal() {
            inboxModal.style.display = 'none';
            showMainContent();
        }
        function renderInboxList() {
            inboxList.innerHTML = '';
            inbox.forEach((reminder, index) => {
                const soundLabel = reminder.sound === 'none' ? '' :
                                  reminder.sound === 'alarm1' ? '🔔' :
                                  reminder.sound === 'alarm2' ? '🔔' :
                                  reminder.sound === 'bell' ? '🔔' :
                                  reminder.sound === 'chime' ? '🔔' : '';
                
                const imageHtml = reminder.imageUrl ? 
                    `<div class="inbox-message-image">
                        <img src="${reminder.imageUrl}" alt="תמונה" class="inbox-item-image" onclick="window.open('${reminder.imageUrl}', '_blank')">
                    </div>` : '';
                
                const dateStr = new Date(reminder.datetime).toLocaleDateString('he-IL');
                const timeStr = new Date(reminder.datetime).toLocaleTimeString('he-IL', { hour: '2-digit', minute: '2-digit' });
                
                const li = document.createElement('li');
                li.className = 'inbox-item';
                li.innerHTML = `
                    <div class="inbox-message-header" onclick="toggleInboxMessage(${index})">
                        <div class="inbox-icon">
                            <i class="fas fa-envelope"></i>
                        </div>
                        <div class="inbox-preview">
                            <div class="inbox-subject">${soundLabel} תזכורת</div>
                            <div class="inbox-snippet">${reminder.text.substring(0, 50)}${reminder.text.length > 50 ? '...' : ''}</div>
                        </div>
                        <div class="inbox-meta">
                            <div class="inbox-date">${dateStr}</div>
                            <div class="inbox-time">${timeStr}</div>
                            <i class="fas fa-chevron-down inbox-toggle-icon" id="inbox-toggle-${index}"></i>
                        </div>
                    </div>
                    <div class="inbox-message-body" id="inbox-body-${index}" style="display:none;">
                        <div class="inbox-message-content">
                            <p>${reminder.text}</p>
                            ${imageHtml}
                        </div>
                        <div class="inbox-message-actions">
                            <button onclick="deleteInbox(${reminder.id})" class="inbox-delete-btn">
                                <i class="fas fa-trash"></i> מחק
                            </button>
                        </div>
                    </div>
                `;
                inboxList.appendChild(li);
            });
            updateInboxBadge();
        }
        
        function toggleInboxMessage(index) {
            const body = document.getElementById(`inbox-body-${index}`);
            const icon = document.getElementById(`inbox-toggle-${index}`);
            
            if (body.style.display === 'none') {
                body.style.display = 'block';
                icon.classList.remove('fa-chevron-down');
                icon.classList.add('fa-chevron-up');
            } else {
                body.style.display = 'none';
                icon.classList.remove('fa-chevron-up');
                icon.classList.add('fa-chevron-down');
            }
        }
        async function deleteInbox(id) {
            inbox = inbox.filter(r => r.id !== id);
            localStorage.setItem('inbox', JSON.stringify(inbox));
            if (auth?.currentUser) {
                saveInboxToFirestore(inbox).catch(e => console.error('Firestore inbox save error:', e));
            }
            renderInboxList();
            updateInboxBadge();
        }
        function openRemindersModal() {
            closeSidebar();
            document.querySelector('.container').style.display = 'none';
            document.querySelector('.top-section-wrapper').style.display = 'none';
            fixedDashboardSection.style.display = 'none';
            remindersModal.style.display = 'flex';
            renderRemindersList();
        }
        function closeRemindersModal() {
            remindersModal.style.display = 'none';
            showMainContent();
        }
        function requestNotificationPermission() {
            if ('Notification' in window) {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        console.log('Notifications permission granted.');
                    }
                });
            }
        }
        // Initialize application on page load
        window.addEventListener('load', async () => {
            // Load stagesConfig from localStorage if available
            const savedStagesConfig = localStorage.getItem('stagesConfig');
            if (savedStagesConfig) {
                try {
                    const parsedConfig = JSON.parse(savedStagesConfig);
                    // Merge custom metrics into stagesConfig
                    Object.keys(parsedConfig).forEach(stageId => {
                        if (parsedConfig[stageId].customMetrics && stagesConfig[stageId]) {
                            stagesConfig[stageId].customMetrics = parsedConfig[stageId].customMetrics;
                        }
                    });
                } catch (e) {
                    console.error('Failed to load stagesConfig from localStorage', e);
                }
            }
            
            // Try to handle invite from URL, but don't let it block the UI initialization
            try {
                await handleInviteFromUrl();
            } catch (e) {
                console.error('Failed to handle invite from URL (null may not be loaded):', e);
            }
            
            // Cloud sync disabled
            loadDarkModeState();
            populateYearSelects();
            setDefaultYearFilter();
            renderAllMainContent();
            updateSharedAccessNotice();
            updateInboxBadge();
            requestNotificationPermission();
            
            // Initialize account switching
            loadConnectedAccounts();
            
            // Firebase messaging removed - service worker registration removed
            
            setInterval(checkReminders, 60000);
            checkReminders();
            const user = auth?.currentUser;
            // Allow offline usage - don't force login modal
            // Users can still login via sidebar if they want cloud sync
            // Cloud sync disabled
            
            // Add touch event listeners for card swipe functionality
            if (projectDetailsCard) {
                projectDetailsCard.addEventListener('touchstart', handleTouchStart);
                projectDetailsCard.addEventListener('touchmove', handleTouchMove);
                projectDetailsCard.addEventListener('touchend', handleTouchEnd);
            }
            
            if (cardFab) {
                // Use a flag to prevent double-firing on touch devices
                let touchHandled = false;
                
                cardFab.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    touchHandled = true;
                    toggleCardFromFab();
                    // Reset flag after a short delay
                    setTimeout(() => { touchHandled = false; }, 300);
                });
                
                cardFab.addEventListener('click', (e) => {
                    if (!touchHandled) {
                        toggleCardFromFab();
                    }
                });
            }
            
            // Initialize card position to prevent flickering
            initializeProjectDetailsCard();
            
            // Remove preload class to enable animations smoothly after initialization
            setTimeout(() => {
                document.body.classList.remove('preload');
                document.body.classList.add('loaded');
            }, 100);
            
            // Set up authentication listeners
            const loginBtn = document.getElementById('loginBtn');
            const logoutBtn = document.getElementById('logoutBtn');
            const changeSitePasswordBtn = document.getElementById('changeSitePasswordBtn');
            const switchBackBtn = document.getElementById('switchBackBtn');
            const authStatus = document.getElementById('authStatus');
            
            if (loginBtn) {
                loginBtn.addEventListener('click', () => {
                    openLoginModal();
                });
            }
            if (logoutBtn) {
                logoutBtn.addEventListener('click', async () => {
                    await signOutUser();
                });
            }
            
            // Setup Firebase Auth state listener
            onAuthChanged(async (user) => {
                if (user) {
                    // Update auth status with account switching info
                    if (currentActiveAccount) {
                        if (authStatus) {
                            authStatus.innerHTML = `מחובר כ: ${user.email}<br><small style="color: var(--secondary-color);">צופה ב: ${currentActiveAccount.ownerEmail}</small>`;
                        }
                        if (switchBackBtn) switchBackBtn.style.display = 'block';
                    } else {
                        if (authStatus) authStatus.textContent = 'מחובר כ: ' + (user.email || user.displayName || user.uid);
                        if (switchBackBtn) switchBackBtn.style.display = 'none';
                    }
                    
                    if (loginBtn) loginBtn.style.display = 'none';
                    if (changeSitePasswordBtn) changeSitePasswordBtn.style.display = ENABLE_SITE_PASSWORD_PROMPT ? 'inline-block' : 'none';
                    if (logoutBtn) logoutBtn.style.display = 'inline-block';
                    
                    // Firebase connection status updates after the first Firestore read.
                    
                    // Load data from Firestore
                    try {
                        showLoading('טוען נתונים מהענן...');
                        const projectsLoaded = await loadProjectsFromFirestore();
                        if (projectsLoaded) {
                            renderCurrentProject();
                        } else if (projects && Object.keys(projects).length > 0) {
                            await saveProjectsToFirestore();
                        }
                        
                        const firestoreReminders = await loadRemindersFromFirestore();
                        if (firestoreReminders && firestoreReminders.length > 0) {
                            reminders = firestoreReminders;
                        } else if (reminders && reminders.length > 0) {
                            await saveRemindersToFirestore(reminders);
                        }
                        
                        const firestoreInbox = await loadInboxFromFirestore();
                        if (firestoreInbox && firestoreInbox.length > 0) {
                            inbox = firestoreInbox;
                        } else if (inbox && inbox.length > 0) {
                            await saveInboxToFirestore(inbox);
                        }
                        
                        hideLoading();
                        showNotification('הנתונים נטענו בהצלחה', 'success');
                    } catch (error) {
                        hideLoading();
                        console.error('Error loading data from Firestore:', error);
                        showNotification('שגיאה בטעינת נתונים מהענן', 'error');
                    }
                    
                    // Render UI
                    renderRemindersList();
                    renderInboxList();
                    updateInboxBadge();
                    
                    // Set up real-time synchronization
                    setupFirestoreListeners();
                    
                    closeLoginModal();
                } else {
                    if (authStatus) authStatus.textContent = 'לא מחובר';
                    if (loginBtn) loginBtn.style.display = 'inline-block';
                    if (changeSitePasswordBtn) changeSitePasswordBtn.style.display = 'none';
                    if (logoutBtn) logoutBtn.style.display = 'none';
                    
                    // Hide Firebase status when logged out
                    updateFirebaseStatus(false);
                    
                    openLoginModal();
                }
            });
            
            // Handle Google sign-in redirect result on page load
            handleRedirectResult();
        });
        function setDefaultYearFilter() {
            const currentYear = new Date().getFullYear().toString();
            projectYearFilter.value = 'all';
            filterProjectsByYear();
        }
        function renderAllMainContent() {
            updateProjectDisplay();
            renderStageNavigation();
        }
        function loadDarkModeState() {
            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            if (isDarkMode) {
                document.body.classList.add('dark-mode');
                darkModeToggle.checked = true;
            } else {
                document.body.classList.remove('dark-mode');
                localStorage.setItem('darkMode', 'false');
            }
        }
        darkModeToggle.addEventListener('change', () => {
            if (darkModeToggle.checked) {
                document.body.classList.add('dark-mode');
                localStorage.setItem('darkMode', 'true');
            } else {
                document.body.classList.remove('dark-mode');
                localStorage.setItem('darkMode', 'false');
            }
        });
        projectYearFilter.addEventListener('change', filterProjectsByYear);
        hamburgerBtn.addEventListener('click', toggleSidebar);
        sidebarOverlay.addEventListener('click', closeSidebar);
        window.addEventListener('resize', handleCardFabResize);
        function toggleSidebar() {
            hamburgerBtn.classList.toggle('open');
            sidebar.classList.toggle('open');
            sidebarOverlay.style.display = sidebar.classList.contains('open') ? 'block' : 'none';
            
            // Update toggle icon direction
            const sidebarToggleIcon = document.getElementById('sidebarToggleIcon');
            if (sidebarToggleIcon) {
                if (sidebar.classList.contains('open')) {
                    sidebarToggleIcon.className = 'fas fa-angle-double-right';
                } else {
                    sidebarToggleIcon.className = 'fas fa-angle-double-left';
                }
            }
        }
        function closeSidebar() {
            hamburgerBtn.classList.remove('open');
            sidebar.classList.remove('open');
            sidebarOverlay.style.display = 'none';
        }
        function showMainContent() {
            historyModal.style.display = 'none';
            projectManagementModal.style.display = 'none';
            financeModal.style.display = 'none';
            currentProjectFinanceReportModal.style.display = 'none';
            globalFinanceReportModal.style.display = 'none';
            financeYearlyModal.style.display = 'none';
            inboxModal.style.display = 'none';
            remindersModal.style.display = 'none';
            instructionsModal.style.display = 'none';
            timelineModal.style.display = 'none';
            datePickerModal.style.display = 'none';
            projectSelectionModal.style.display = 'none';
            document.querySelector('.container').style.display = 'block';
            document.querySelector('.top-section-wrapper').style.display = 'block';
            currentStageContent.style.display = 'block';
            stageNavContainer.style.display = 'flex';
            projectDetailsCard.style.display = 'block';
            fixedDashboardSection.style.display = 'flex';
            // Always show stage overview container
            stageOverviewContainer.style.display = 'block';
        }
        function createNewProjectData(name) {
            const newProject = {
                name: name,
                isClosed: false,
                wineDetails: {
                    customProperties: []
                },
                stages: {},
                finance: []
            };
            for(const metricId in stagesConfig.wineDetails.metrics) {
                newProject.wineDetails[metricId] = [];
            }
            for (const stageId in stagesConfig) {
                if (stageId === 'wineDetails') continue;
                newProject.stages[stageId] = {};
                for (const metricId in stagesConfig[stageId].metrics) {
                    newProject.stages[stageId][metricId] = [];
                }
            }
            return newProject;
        }
        function loadProjects() {
            const storedProjects = localStorage.getItem('projects');
            let loaded = storedProjects ? JSON.parse(storedProjects) : {};
            if (Object.keys(loaded).length === 0) {
                loaded['default_project'] = createNewProjectData('פרויקט ראשי');
            }
            for (const projectId in loaded) {
                const project = loaded[projectId];
                if (project.isClosed === undefined) project.isClosed = false;
                if (!project.wineDetails) {
                    project.wineDetails = {};
                    const oldStage7 = project.stages && project.stages['stage7'];
                    if (oldStage7) {
                        if (oldStage7.wineName && oldStage7.wineName.length > 0) project.wineDetails.wineName = oldStage7.wineName;
                        if (oldStage7.vintageYear && oldStage7.vintageYear.length > 0) project.wineDetails.vintageYear = oldStage7.vintageYear;
                        if (oldStage7.generalNotes && oldStage7.generalNotes.length > 0) project.wineDetails.generalNotes = oldStage7.generalNotes;
                    }
                    const oldStage1 = project.stages && project.stages['stage1'];
                     if (oldStage1) {
                        if (oldStage1.harvestDate && oldStage1.harvestDate.length > 0) project.wineDetails.harvestDate = oldStage1.harvestDate;
                        if (oldStage1.grapeVariety && oldStage1.grapeVariety.length > 0) project.wineDetails.grapeVariety = oldStage1.grapeVariety;
                        if (oldStage1.vineyardSource && oldStage1.vineyardSource.length > 0) project.wineDetails.vineyardSource = oldStage1.vineyardSource;
                    }
                }
                for(const metricId in stagesConfig.wineDetails.metrics) {
                    if (!project.wineDetails[metricId]) {
                        project.wineDetails[metricId] = [];
                    }
                }
                if (!project.wineDetails.customProperties) {
                    project.wineDetails.customProperties = [];
                }
                if (!project.finance) {
                    project.finance = project.expenses || [];
                    if (project.expenses) delete project.expenses;
                }
                if (!project.stages) {
                    project.stages = {};
                }
                for (const stageId in stagesConfig) {
                    if (stageId === 'wineDetails') continue;
                    if (!project.stages[stageId]) {
                        project.stages[stageId] = {};
                    }
                    for (const metricId in stagesConfig[stageId].metrics) {
                        if (!project.stages[stageId][metricId]) {
                            project.stages[stageId][metricId] = [];
                        }
                    }
                }
                if (project.stages && project.stages['stage7'] && !stagesConfig['stage7']) {
                    delete project.stages['stage7'];
                }
            }
            return loaded;
        }
        
        // ========== Firestore Data Management Functions ==========
        
        /**
         * Save projects to Firestore
         */
        async function saveProjectsToFirestore() {
            try {
                await waitForFirebase();
                if (!auth?.currentUser) {
                    console.warn('User not authenticated, skipping Firestore save');
                    return;
                }
                
                const userId = auth.currentUser.uid;
                console.log('Saving projects to Firestore for user:', userId);
                await window.firestoreSetDoc(
                    window.firestoreDoc(window.firebaseDb, 'users', userId, 'data', 'projects'),
                    { projects: projects, stagesConfig: stagesConfig, updatedAt: window.firestoreServerTimestamp() }
                );
                console.log('✓ Projects saved to Firestore successfully');
            } catch (error) {
                console.error('❌ Error saving projects to Firestore:', error);
                console.error('Error code:', error.code);
                console.error('Error message:', error.message);
                updateFirebaseStatus(false);
                
                if (error.code === 'permission-denied') {
                    console.error('Permission denied - check Firestore security rules');
                    showNotification('שגיאת הרשאה בשמירת פרויקטים', 'error');
                }
            }
        }
        
        /**
         * Load projects from Firestore
         */
        async function loadProjectsFromFirestore() {
            try {
                await waitForFirebase();
                if (!auth?.currentUser) {
                    console.warn('User not authenticated, loading from localStorage');
                    return false;
                }
                
                const userId = auth.currentUser.uid;
                console.log('Loading projects from Firestore for user:', userId);
                const docRef = window.firestoreDoc(window.firebaseDb, 'users', userId, 'data', 'projects');
                const docSnap = await window.firestoreGetDoc(docRef);
                updateFirebaseStatusFromSnapshot(docSnap);
                
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    if (data.projects) {
                        projects = data.projects;
                    }
                    if (data.stagesConfig) {
                        stagesConfig = data.stagesConfig;
                    }
                    console.log('✓ Projects loaded from Firestore successfully');
                    return true;
                }
                console.log('No projects found in Firestore');
                return false;
            } catch (error) {
                console.error('❌ Error loading projects from Firestore:', error);
                console.error('Error code:', error.code);
                console.error('Error message:', error.message);
                updateFirebaseStatus(false);
                return false;
            }
        }
        
        /**
         * Save reminders to Firestore
         */
        async function saveRemindersToFirestore(reminders) {
            try {
                await waitForFirebase();
                if (!auth?.currentUser) return;
                
                const userId = auth.currentUser.uid;
                await window.firestoreSetDoc(
                    window.firestoreDoc(window.firebaseDb, 'users', userId, 'data', 'reminders'),
                    { reminders: reminders, updatedAt: window.firestoreServerTimestamp() }
                );
                console.log('Reminders saved to Firestore');
            } catch (error) {
                console.error('Error saving reminders to Firestore:', error);
                updateFirebaseStatus(false);
            }
        }
        
        /**
         * Load reminders from Firestore
         */
        async function loadRemindersFromFirestore() {
            try {
                await waitForFirebase();
                if (!auth?.currentUser) return [];
                
                const userId = auth.currentUser.uid;
                const docRef = window.firestoreDoc(window.firebaseDb, 'users', userId, 'data', 'reminders');
                const docSnap = await window.firestoreGetDoc(docRef);
                updateFirebaseStatusFromSnapshot(docSnap);
                
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    console.log('Reminders loaded from Firestore');
                    return data.reminders || [];
                }
                return [];
            } catch (error) {
                console.error('Error loading reminders from Firestore:', error);
                updateFirebaseStatus(false);
                return [];
            }
        }
        
        /**
         * Save inbox to Firestore
         */
        async function saveInboxToFirestore(inbox) {
            try {
                await waitForFirebase();
                if (!auth?.currentUser) return;
                
                const userId = auth.currentUser.uid;
                await window.firestoreSetDoc(
                    window.firestoreDoc(window.firebaseDb, 'users', userId, 'data', 'inbox'),
                    { inbox: inbox, updatedAt: window.firestoreServerTimestamp() }
                );
                console.log('Inbox saved to Firestore');
            } catch (error) {
                console.error('Error saving inbox to Firestore:', error);
                updateFirebaseStatus(false);
            }
        }
        
        /**
         * Load inbox from Firestore
         */
        async function loadInboxFromFirestore() {
            try {
                await waitForFirebase();
                if (!auth?.currentUser) return [];
                
                const userId = auth.currentUser.uid;
                const docRef = window.firestoreDoc(window.firebaseDb, 'users', userId, 'data', 'inbox');
                const docSnap = await window.firestoreGetDoc(docRef);
                updateFirebaseStatusFromSnapshot(docSnap);
                
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    console.log('Inbox loaded from Firestore');
                    return data.inbox || [];
                }
                return [];
            } catch (error) {
                console.error('Error loading inbox from Firestore:', error);
                updateFirebaseStatus(false);
                return [];
            }
        }
        
        /**
         * Setup real-time listeners for Firestore
         */
        function setupFirestoreListeners() {
            waitForFirebase().then(() => {
                if (!auth?.currentUser) return;
                
                const userId = auth.currentUser.uid;
                // Include metadata updates so cache/server changes trigger status updates via fromCache.
                const listenerOptions = { includeMetadataChanges: true };
                
                // Listen to projects changes
                const projectsRef = window.firestoreDoc(window.firebaseDb, 'users', userId, 'data', 'projects');
                window.firestoreOnSnapshot(projectsRef, listenerOptions, (doc) => {
                    if (doc.exists()) {
                        const data = doc.data();
                        if (data.projects) {
                            projects = data.projects;
                            renderCurrentProject();
                        }
                        if (data.stagesConfig) {
                            stagesConfig = data.stagesConfig;
                        }
                    }
                    updateFirebaseStatusFromSnapshot(doc);
                }, (error) => {
                    console.error('Error in projects listener:', error);
                    updateFirebaseStatus(false);
                });
                
                // Listen to reminders changes
                const remindersRef = window.firestoreDoc(window.firebaseDb, 'users', userId, 'data', 'reminders');
                window.firestoreOnSnapshot(remindersRef, listenerOptions, (doc) => {
                    if (doc.exists()) {
                        const data = doc.data();
                        if (data.reminders) {
                            reminders = data.reminders;
                            updateRemindersDisplay();
                        }
                    }
                    updateFirebaseStatusFromSnapshot(doc);
                }, (error) => {
                    console.error('Error in reminders listener:', error);
                    updateFirebaseStatus(false);
                });
                
                // Listen to inbox changes
                const inboxRef = window.firestoreDoc(window.firebaseDb, 'users', userId, 'data', 'inbox');
                window.firestoreOnSnapshot(inboxRef, listenerOptions, (doc) => {
                    if (doc.exists()) {
                        const data = doc.data();
                        if (data.inbox) {
                            inbox = data.inbox;
                            updateInboxBadge();
                        }
                    }
                    updateFirebaseStatusFromSnapshot(doc);
                }, (error) => {
                    console.error('Error in inbox listener:', error);
                    updateFirebaseStatus(false);
                });
                
                console.log('Firestore real-time listeners setup complete');
            });
        }
        
        function saveAllProjects() {
            if (sharedAccessContext.active && !sharedAccessContext.allowEdit && !sharedAccessContext.allowFinance) {
                console.warn('View-only mode - changes not saved');
                return;
            }
            try {
                localStorage.setItem('projects', JSON.stringify(projects));
                localStorage.setItem('stagesConfig', JSON.stringify(stagesConfig)); // Save stagesConfig too
            } catch (storageErr) {
                handleLocalStorageError(storageErr);
            }
            // Save to Firestore
            saveProjectsToFirestore().catch(e => console.error('Firestore save error:', e));
        }
        
        /**
         * Persist projects to localStorage (alias for saveAllProjects)
         */
        function persistProjects() {
            saveAllProjects();
        }
        
        /**
         * Save a project detail value and persist immediately
         * @param {string} metricId - The metric ID (e.g., 'wineName', 'vintageYear')
         * @param {string} value - The value to save
         */
        function saveProjectDetailValue(metricId, value) {
            if (!currentProjectId || !projects[currentProjectId]) return;
            if (!projects[currentProjectId].wineDetails) {
                projects[currentProjectId].wineDetails = {};
            }
            
            // Initialize array if doesn't exist
            if (!projects[currentProjectId].wineDetails[metricId]) {
                projects[currentProjectId].wineDetails[metricId] = [];
            }
            
            // Add new entry with timestamp
            const timestamp = new Date().toLocaleString('he-IL');
            projects[currentProjectId].wineDetails[metricId].push({ value, timestamp });
            
            // Persist immediately
            persistProjects();
        }
        
        /**
         * Save a stage metric value and persist immediately
         * @param {string} sectionId - The stage/section ID (e.g., 'stage1', 'stage2')
         * @param {string} metricId - The metric ID (e.g., 'brix', 'ph')
         * @param {string} value - The value to save
         */
        function saveStageMetricValue(sectionId, metricId, value) {
            if (!currentProjectId || !projects[currentProjectId]) return;
            if (!projects[currentProjectId].stages) {
                projects[currentProjectId].stages = {};
            }
            if (!projects[currentProjectId].stages[sectionId]) {
                projects[currentProjectId].stages[sectionId] = {};
            }
            
            // Initialize array if doesn't exist
            if (!projects[currentProjectId].stages[sectionId][metricId]) {
                projects[currentProjectId].stages[sectionId][metricId] = [];
            }
            
            // Add new entry with timestamp
            const timestamp = new Date().toLocaleString('he-IL');
            projects[currentProjectId].stages[sectionId][metricId].push({ value, timestamp });
            
            // Persist immediately
            persistProjects();
        }
        
        function updateProjectDisplay() {
            currentProjectNameDisplay.textContent = projects[currentProjectId].name;
            editProjectNameInput.value = projects[currentProjectId].name;
            loadCurrentStageContent();
            updateProjectDetailsCard();
        }
        function openProjectManagementModal() {
            closeSidebar();
            document.querySelector('.container').style.display = 'none';
            document.querySelector('.top-section-wrapper').style.display = 'none';
            fixedDashboardSection.style.display = 'none';
            projectManagementModal.style.display = 'flex';
            filterProjectsByYear();
        }
        function closeProjectManagementModal() {
            projectManagementModal.style.display = 'none';
            showMainContent();
        }
        function filterProjectsByYear() {
            const selectedYear = projectYearFilter.value;
            renderProjectList(selectedYear);
        }
        function openAccessControlModal() {
            const user = auth?.currentUser;
            if (!user) {
                alert('התחבר כדי לנהל הרשאות שיתוף.');
                openLoginModal();
                return;
            }
            populateUserProjectSelect();
            loadActiveUsers();
            clearAccessForm();
            closeSidebar();
            document.querySelector('.container').style.display = 'none';
            document.querySelector('.top-section-wrapper').style.display = 'none';
            fixedDashboardSection.style.display = 'none';
            accessControlModal.style.display = 'flex';
        }
        
        function switchAccessTab(tabName) {
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.access-tab-content');
            tabContents.forEach(content => content.classList.remove('active'));
            
            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.access-tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Show selected tab content
            const selectedContent = document.getElementById(tabName + 'Tab');
            if (selectedContent) {
                selectedContent.classList.add('active');
            }
            
            // Add active class to clicked tab
            const clickedTab = event?.target.closest('.access-tab');
            if (clickedTab) {
                clickedTab.classList.add('active');
            }
        }
        
        function closeAccessControlModal() {
            if (accessControlModal) {
                accessControlModal.style.display = 'none';
                showMainContent();
            }
        }
        
        function populateUserProjectSelect() {
            const select = document.getElementById('userProjectAccess');
            if (!select) return;
            const currentValue = select.value;
            select.innerHTML = '<option value="all">כל הפרויקטים</option>';
            Object.keys(projects).forEach(id => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = projects[id].name;
                select.appendChild(option);
            });
            if (currentValue) {
                select.value = currentValue;
            }
        }
        
        function clearAccessForm() {
            const emailInput = document.getElementById('newUserEmail');
            const projectSelect = document.getElementById('userProjectAccess');
            const viewRadio = document.getElementById('permView');
            const financeCheckbox = document.getElementById('userFinanceAccess');
            
            if (emailInput) emailInput.value = '';
            if (projectSelect) projectSelect.value = 'all';
            if (viewRadio) viewRadio.checked = true;
            if (financeCheckbox) financeCheckbox.checked = false;
        }
        async function grantUserAccess() {
            const user = auth?.currentUser;
            if (!user) {
                alert('נדרש להתחבר כדי להעניק גישה.');
                return;
            }
            
            const emailInput = document.getElementById('newUserEmail');
            const projectSelect = document.getElementById('userProjectAccess');
            const editRadio = document.getElementById('permEdit');
            const financeCheckbox = document.getElementById('userFinanceAccess');
            
            const targetEmail = emailInput?.value.trim();
            const projectId = projectSelect?.value || 'all';
            const allowEdit = editRadio?.checked || false;
            const allowFinance = financeCheckbox?.checked || false;
            
            if (!targetEmail) {
                alert('אנא הזן כתובת מייל.');
                return;
            }
            
            // Validate email format
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(targetEmail)) {
                alert('כתובת המייל אינה תקינה.');
                return;
            }
            
            try {
                // Store user access directly in Firestore
                const accessId = AccessManagement.grantAccess(
                    targetEmail,
                    projectId,
                    allowEdit,
                    allowFinance
                );
                
                alert(`גישה הוענקה בהצלחה ל-${targetEmail}`);
                clearAccessForm();
                await loadActiveUsers();
            } catch (err) {
                console.error('Error granting access:', err);
                if (err.code === 'permission-denied') {
                    alert('שגיאה: אין לך הרשאה להעניק גישה. ודא שהחוקים ב-Firestore מוגדרים כראוי.');
                } else {
                    alert('הענקת הגישה נכשלה: ' + (err.message || 'נסה שוב.'));
                }
            }
        }
        
        async function loadActiveUsers() {
            const user = auth?.currentUser;
            const usersList = document.getElementById('activeUsersList');
            const noUsersMsg = document.getElementById('noUsersMessage');
            
            if (!user || !usersList) return;
            
            try {
                const activeUsers = AccessManagement.getActiveUsers();
                
                usersList.innerHTML = '';
                
                if (activeUsers.length === 0) {
                    if (noUsersMsg) noUsersMsg.style.display = 'block';
                    return;
                }
                
                if (noUsersMsg) noUsersMsg.style.display = 'none';
                
                activeUsers.forEach(data => {
                    // data already available
                    const li = document.createElement('li');
                    li.className = 'user-access-item';
                    
                    const projectName = data.projectId ? (projects[data.projectId]?.name || data.projectId) : 'כל הפרויקטים';
                    const permissionText = data.allowEdit ? 'עריכה' : 'צפייה בלבד';
                    const financeText = data.allowFinance ? 'כולל כספים' : 'ללא כספים';
                    
                    li.innerHTML = `
                        <div class="user-info">
                            <div class="user-email">
                                <i class="fas fa-user"></i>
                                <strong>${data.userEmail}</strong>
                            </div>
                            <div class="user-permissions">
                                <span class="permission-badge ${data.allowEdit ? 'edit' : 'view'}">
                                    <i class="fas ${data.allowEdit ? 'fa-edit' : 'fa-eye'}"></i>
                                    ${permissionText}
                                </span>
                                <span class="permission-badge project">
                                    <i class="fas fa-folder"></i>
                                    ${projectName}
                                </span>
                                <span class="permission-badge ${data.allowFinance ? 'finance-yes' : 'finance-no'}">
                                    <i class="fas fa-${data.allowFinance ? 'dollar-sign' : 'ban'}"></i>
                                    ${financeText}
                                </span>
                            </div>
                        </div>
                        <div class="user-actions">
                            <button class="btn-edit" onclick="editUserAccess('${data.id}')" title="ערוך הרשאות">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button class="btn-delete" onclick="revokeUserAccess('${data.id}', '${data.userEmail}')" title="שלול גישה">
                                <i class="fas fa-user-times"></i>
                            </button>
                        </div>
                    `;
                    usersList.appendChild(li);
                });
            } catch (err) {
                console.error('Error loading users:', err);
                if (err.code === 'failed-precondition') {
                    // null error handling removed
                    if (noUsersMsg) {
                        noUsersMsg.textContent = 'נדרש אינדקס ב-Firestore. אנא צור קשר עם מנהל המערכת.';
                        noUsersMsg.style.display = 'block';
                    }
                } else if (err.code === 'permission-denied') {
                    console.error('Permission denied loading users. Check Firestore rules.');
                    if (noUsersMsg) {
                        noUsersMsg.textContent = 'שגיאת הרשאה. אנא צור קשר עם מנהל המערכת.';
                        noUsersMsg.style.display = 'block';
                    }
                } else {
                    if (noUsersMsg) {
                        noUsersMsg.textContent = 'שגיאה בטעינת משתמשים. נסה שוב מאוחר יותר.';
                        noUsersMsg.style.display = 'block';
                    }
                }
            }
        }
        
        async function revokeUserAccess(accessId, userEmail) {
            if (!confirm(`האם לשלול את הגישה של ${userEmail}?`)) {
                return;
            }
            
            try {
                AccessManagement.revokeAccess(accessId);
                
                alert('הגישה נשללה בהצלחה');
                await loadActiveUsers();
            } catch (err) {
                console.error('Error revoking access:', err);
                if (err.code === 'permission-denied') {
                    alert('שגיאת הרשאה: אין לך הרשאה לשלול גישה זו.');
                } else if (err.code === 'not-found') {
                    alert('רשומת הגישה לא נמצאה.');
                } else {
                    alert('שלילת הגישה נכשלה: ' + (err.message || 'נסה שוב'));
                }
            }
        }
        
        async function editUserAccess(accessId) {
            // TODO: Implement edit functionality
            alert('עריכת הרשאות תתאפשר בקרוב');
        }
        
        // ============= Account Switching Functions =============
        
        /**
         * Store for connected accounts
         */
        let connectedAccounts = [];
        let currentActiveAccount = null;
        
        /**
         * Load connected accounts from localStorage
         */
        function loadConnectedAccounts() {
            try {
                const stored = localStorage.getItem('connectedAccounts');
                if (stored) {
                    connectedAccounts = JSON.parse(stored);
                }
                const activeAccount = localStorage.getItem('activeAccount');
                if (activeAccount) {
                    currentActiveAccount = JSON.parse(activeAccount);
                }
            } catch (error) {
                console.error('Error loading connected accounts:', error);
                connectedAccounts = [];
                currentActiveAccount = null;
            }
        }
        
        /**
         * Save connected accounts to localStorage
         */
        function saveConnectedAccounts() {
            try {
                localStorage.setItem('connectedAccounts', JSON.stringify(connectedAccounts));
                if (currentActiveAccount) {
                    localStorage.setItem('activeAccount', JSON.stringify(currentActiveAccount));
                }
            } catch (error) {
                console.error('Error saving connected accounts:', error);
            }
        }
        
        /**
         * Open account switching modal
         */
        function openAccountSwitchModal() {
            const modal = document.getElementById('accountSwitchModal');
            if (!modal) return;
            
            loadConnectedAccounts();
            updateCurrentAccountDisplay();
            renderConnectedAccounts();
            
            modal.style.display = 'flex';
        }
        
        /**
         * Close account switching modal
         */
        function closeAccountSwitchModal() {
            const modal = document.getElementById('accountSwitchModal');
            if (modal) {
                modal.style.display = 'none';
                showMainContent();
            }
        }
        
        /**
         * Update current account display
         */
        function updateCurrentAccountDisplay() {
            const display = document.getElementById('currentAccountDisplay');
            if (!display) return;
            
            const user = auth?.currentUser;
            if (user) {
                display.innerHTML = `
                    <div class="current-account-card">
                        <i class="fas fa-user-circle" style="font-size: 3em; color: var(--primary-color);"></i>
                        <div style="margin-right: 15px;">
                            <p style="font-weight: bold; margin: 5px 0;">${user.email || user.displayName || 'משתמש'}</p>
                            <p style="color: var(--text-light); font-size: 0.9em;">UID: ${user.uid.substring(0, 8)}...</p>
                        </div>
                    </div>
                `;
            } else {
                display.innerHTML = '<p style="color: var(--text-light);">לא מחובר</p>';
            }
        }
        
        /**
         * Connect to another account
         */
        async function connectToAccount() {
            const emailInput = document.getElementById('connectAccountEmail');
            if (!emailInput) return;
            
            const targetEmail = emailInput.value.trim();
            if (!targetEmail) {
                showNotification('אנא הזן כתובת מייל', 'error');
                return;
            }
            
            // Validate email format
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(targetEmail)) {
                showNotification('כתובת המייל אינה תקינה', 'error');
                return;
            }
            
            const currentUser = auth?.currentUser;
            if (!currentUser) {
                showNotification('נדרש להתחבר תחילה', 'error');
                return;
            }
            
            // Don't allow connecting to own account
            if (targetEmail === currentUser.email) {
                showNotification('לא ניתן להתחבר לחשבון שלך עצמך', 'error');
                return;
            }
            
            try {
                showLoading('בודק הרשאות גישה...');
                await waitForFirebase();
                
                // Check if the current user has access to the target account
                // Query the access collection to see if targetEmail granted access to currentUser.email
                const accessQuery = window.firestoreQuery(
                    window.firestoreCollection(window.firebaseDb, 'access'),
                    window.firestoreWhere('ownerEmail', '==', targetEmail),
                    window.firestoreWhere('userEmail', '==', currentUser.email)
                );
                
                const querySnapshot = await window.firestoreGetDocs(accessQuery);
                
                if (querySnapshot.empty) {
                    hideLoading();
                    showNotification('אין לך הרשאת גישה לחשבון זה', 'error');
                    return;
                }
                
                // Access granted, add to connected accounts
                const accessDoc = querySnapshot.docs[0];
                const accessData = accessDoc.data();
                
                // Check if already connected
                const alreadyConnected = connectedAccounts.find(acc => acc.email === targetEmail);
                if (alreadyConnected) {
                    hideLoading();
                    showNotification('החשבון כבר מחובר', 'warning');
                    return;
                }
                
                connectedAccounts.push({
                    email: targetEmail,
                    connectedAt: new Date().toISOString(),
                    permissions: {
                        allowEdit: accessData.allowEdit || false,
                        allowFinance: accessData.allowFinance || false,
                        projectId: accessData.projectId || 'all'
                    }
                });
                
                saveConnectedAccounts();
                renderConnectedAccounts();
                
                emailInput.value = '';
                hideLoading();
                showNotification('החשבון חובר בהצלחה!', 'success');
            } catch (error) {
                hideLoading();
                console.error('Error connecting account:', error);
                showNotification('שגיאה בחיבור החשבון: ' + (error.message || 'נסה שוב'), 'error');
            }
        }
        
        /**
         * Render connected accounts list
         */
        function renderConnectedAccounts() {
            const list = document.getElementById('connectedAccountsList');
            const noAccountsMsg = document.getElementById('noConnectedAccountsMessage');
            
            if (!list || !noAccountsMsg) return;
            
            list.innerHTML = '';
            
            if (connectedAccounts.length === 0) {
                list.style.display = 'none';
                noAccountsMsg.style.display = 'block';
                return;
            }
            
            list.style.display = 'block';
            noAccountsMsg.style.display = 'none';
            
            connectedAccounts.forEach((account, index) => {
                const li = document.createElement('li');
                li.className = 'connected-account-item';
                li.innerHTML = `
                    <div class="account-info">
                        <div class="account-email">
                            <i class="fas fa-envelope"></i>
                            <strong>${account.email}</strong>
                        </div>
                        <div class="account-permissions">
                            <span class="permission-badge ${account.permissions.allowEdit ? 'edit' : 'view'}">
                                <i class="fas ${account.permissions.allowEdit ? 'fa-edit' : 'fa-eye'}"></i>
                                ${account.permissions.allowEdit ? 'עריכה' : 'צפייה'}
                            </span>
                        </div>
                    </div>
                    <div class="account-actions">
                        <button class="btn-primary" onclick="switchToAccount('${account.email}')" title="עבור לחשבון">
                            <i class="fas fa-exchange-alt"></i> עבור
                        </button>
                        <button class="btn-delete" onclick="disconnectAccount(${index})" title="נתק חשבון">
                            <i class="fas fa-unlink"></i>
                        </button>
                    </div>
                `;
                list.appendChild(li);
            });
        }
        
        /**
         * Switch to a connected account
         */
        async function switchToAccount(targetEmail) {
            const currentUser = auth?.currentUser;
            if (!currentUser) {
                showNotification('נדרש להתחבר תחילה', 'error');
                return;
            }
            
            try {
                showLoading('עובר לחשבון...');
                
                // Find the connected account
                const account = connectedAccounts.find(acc => acc.email === targetEmail);
                if (!account) {
                    hideLoading();
                    showNotification('חשבון לא נמצא', 'error');
                    return;
                }
                
                // Set the active account context
                currentActiveAccount = {
                    ownerEmail: targetEmail,
                    viewerEmail: currentUser.email,
                    permissions: account.permissions
                };
                
                saveConnectedAccounts();
                
                // Reload data for the new account
                // This is a simplified implementation - in production, you'd need to
                // query Firestore with the owner's email to get their data
                showNotification(`עברת לחשבון של ${targetEmail}`, 'success');
                
                // Update UI to show we're viewing another account
                const authStatus = document.getElementById('authStatus');
                if (authStatus) {
                    authStatus.innerHTML = `מחובר כ: ${currentUser.email}<br><small style="color: var(--secondary-color);">צופה ב: ${targetEmail}</small>`;
                }
                
                hideLoading();
                closeAccountSwitchModal();
                
                // Reload the page to refresh all data
                location.reload();
            } catch (error) {
                hideLoading();
                console.error('Error switching account:', error);
                showNotification('שגיאה במעבר לחשבון: ' + (error.message || 'נסה שוב'), 'error');
            }
        }
        
        /**
         * Switch back to own account
         */
        async function switchToOwnAccount() {
            currentActiveAccount = null;
            localStorage.removeItem('activeAccount');
            
            const currentUser = auth?.currentUser;
            const authStatus = document.getElementById('authStatus');
            if (authStatus && currentUser) {
                authStatus.textContent = 'מחובר כ: ' + (currentUser.email || currentUser.displayName || currentUser.uid);
            }
            
            showNotification('חזרת לחשבון שלך', 'success');
            
            // Reload the page to refresh all data
            location.reload();
        }
        
        /**
         * Disconnect a connected account
         */
        async function disconnectAccount(index) {
            if (index < 0 || index >= connectedAccounts.length) return;
            
            const account = connectedAccounts[index];
            
            // Use custom confirmation modal if available
            const confirmed = await new Promise((resolve) => {
                if (typeof showConfirmation === 'function') {
                    showConfirmation(
                        'ניתוק חשבון',
                        `האם לנתק את החיבור לחשבון ${account.email}?`,
                        () => resolve(true),
                        () => resolve(false)
                    );
                } else {
                    // Fallback to native confirm
                    resolve(confirm(`האם לנתק את החיבור לחשבון ${account.email}?`));
                }
            });
            
            if (!confirmed) return;
            
            connectedAccounts.splice(index, 1);
            saveConnectedAccounts();
            renderConnectedAccounts();
            
            showNotification('החשבון נותק בהצלחה', 'success');
        }
        
        // ============= End Account Switching Functions =============
        
        function renderProjectList(yearFilter = 'all') {
            projectList.innerHTML = '';
            let projectsToDisplay = Object.keys(projects).map(id => ({ id, ...projects[id] }));
            if (sharedAccessContext.active && sharedAccessContext.allowedProjectId) {
                projectsToDisplay = projectsToDisplay.filter(p => p.id === sharedAccessContext.allowedProjectId);
            }
            if (yearFilter !== 'all') {
                projectsToDisplay = projectsToDisplay.filter(project => {
                    const vintageYearEntries = project.wineDetails.vintageYear;
                    if (vintageYearEntries && vintageYearEntries.length > 0) {
                        const latestYear = vintageYearEntries[vintageYearEntries.length - 1].value;
                        return latestYear == yearFilter;
                    }
                    return false;
                });
                // then display as before
            } else {
                const yearGroups = {};
                projectsToDisplay.forEach(project => {
                    const vintageYearEntries = project.wineDetails.vintageYear;
                    const year = vintageYearEntries && vintageYearEntries.length > 0 ? vintageYearEntries[vintageYearEntries.length - 1].value : 'לא צוין';
                    if (!yearGroups[year]) yearGroups[year] = [];
                    yearGroups[year].push(project);
                });
                const sortedYears = Object.keys(yearGroups).sort((a,b) => {
                    if (a === 'לא צוין') return 1;
                    if (b === 'לא צוין') return -1;
                    return b - a;
                });
                sortedYears.forEach(year => {
                    const yearHeader = document.createElement('h3');
                    yearHeader.textContent = year === 'לא צוין' ? 'שנים לא צוינו' : `שנה ${year}`;
                    yearHeader.style.color = 'var(--primary-color)';
                    yearHeader.style.borderBottom = '2px solid var(--border-color)';
                    yearHeader.style.paddingBottom = '10px';
                    yearHeader.style.marginBottom = '10px';
                    projectList.appendChild(yearHeader);
                    yearGroups[year].sort((a,b) => a.name.localeCompare(b.name)).forEach(project => {
                        const listItem = document.createElement('li');
                        listItem.setAttribute('data-project-id', project.id);
                        if (project.id === currentProjectId) {
                            listItem.classList.add('active-project');
                        }
                        if (project.isClosed) {
                            listItem.classList.add('closed');
                        }
                        const vintageYearEntries = project.wineDetails.vintageYear;
                        const year = vintageYearEntries && vintageYearEntries.length > 0 ? vintageYearEntries[vintageYearEntries.length - 1].value : 'לא צוין';
                        listItem.innerHTML = `
                            <span>${project.name} (${year})</span>
                            <div class="project-actions">
                                <button onclick="switchProject('${project.id}')">${project.id === currentProjectId ? 'נוכחי' : 'בחר'}</button>
                                <button class="close-project" onclick="toggleProjectClosed('${project.id}')">${project.isClosed ? 'פתח' : 'סגור'}</button>
                                ${project.id !== 'default_project' || Object.keys(projects).length > 1 ? `<button class="delete" onclick="deleteProject('${project.id}')">מחק</button>` : ''}
                            </div>
                        `;
                        projectList.appendChild(listItem);
                    });
                });
                return;
            }
            projectsToDisplay.sort((a, b) => a.name.localeCompare(b.name)).forEach(project => {
                const listItem = document.createElement('li');
                listItem.setAttribute('data-project-id', project.id);
                if (project.id === currentProjectId) {
                    listItem.classList.add('active-project');
                }
                if (project.isClosed) {
                    listItem.classList.add('closed');
                }
                const vintageYearEntries = project.wineDetails.vintageYear;
                const year = vintageYearEntries && vintageYearEntries.length > 0 ? vintageYearEntries[vintageYearEntries.length - 1].value : 'לא צוין';
                listItem.innerHTML = `
                    <span>${project.name} (${year})</span>
                    <div class="project-actions">
                        <button onclick="switchProject('${project.id}')">${project.id === currentProjectId ? 'נוכחי' : 'בחר'}</button>
                        <button class="close-project" onclick="toggleProjectClosed('${project.id}')">${project.isClosed ? 'פתח' : 'סגור'}</button>
                        ${project.id !== 'default_project' || Object.keys(projects).length > 1 ? `<button class="delete" onclick="deleteProject('${project.id}')">מחק</button>` : ''}
                    </div>
                `;
                projectList.appendChild(listItem);
            });
        }
        function toggleProjectClosed(projectId) {
            if (!ensureEditPermission(projectId)) {
                return;
            }
            projects[projectId].isClosed = !projects[projectId].isClosed;
            saveAllProjects();
            filterProjectsByYear();
        }
        function addNewProject() {
            if (newProjectModal && newProjectNameInput) {
                newProjectNameInput.value = '';
                newProjectModal.style.display = 'flex';
                setTimeout(() => newProjectNameInput.focus(), 0);
            }
        }
        /**
         * @param {string} [manualName] optional name for backward compatibility when modal is unavailable
         */
        function confirmAddNewProject(manualName) {
            if (!ensureEditPermission()) {
                return;
            }
            // Allow creating projects even without authentication for offline usage
            // Cloud sync disabled
            const nameFromModal = newProjectNameInput ? newProjectNameInput.value.trim() : '';
            const newProjectName = manualName || nameFromModal;
            if (newProjectName) {
                const newProjectId = `project_${Date.now()}`;
                projects[newProjectId] = createNewProjectData(newProjectName.trim());
                saveAllProjects();
                switchProject(newProjectId);
                filterProjectsByYear();
                closeNewProjectModal();
            } else {
                alert('אנא הזן שם לפרויקט.');
            }
        }
        function closeNewProjectModal() {
            if (newProjectModal) {
                newProjectModal.style.display = 'none';
            }
        }
        function switchProject(id) {
            if (!ensureProjectAccess(id)) {
                return;
            }
            if (projects[id].isClosed) {
                alert('לא ניתן לעבוד על פרויקט סגור. פתח אותו קודם.');
                return;
            }
            currentProjectId = id;
            localStorage.setItem('currentProjectId', currentProjectId);
            loadCurrentStageContent();
            updateProjectDisplay();
            closeProjectManagementModal();
        }
        function deleteProject(id) {
            if (!ensureEditPermission(id)) {
                return;
            }
            if (confirm('האם אתה בטוח שברצונך למחוק את הפרויקט "${projects[id].name}"? כל הנתונים יימחקו לצמיתות.')) {
                delete projects[id];
                if (currentProjectId === id) {
                    const remainingProjects = Object.keys(projects).filter(pid => !projects[pid].isClosed);
                    if (remainingProjects.length > 0) {
                        currentProjectId = remainingProjects[0];
                    } else {
                        currentProjectId = Object.keys(projects)[0];
                        if (!currentProjectId) {
                             currentProjectId = 'default_project';
                             projects[currentProjectId] = createNewProjectData('פרויקט ראשי');
                        }
                    }
                }
                saveAllProjects();
                localStorage.setItem('currentProjectId', currentProjectId);
                updateProjectDisplay();
                filterProjectsByYear();
            }
        }
        currentProjectNameDisplay.addEventListener('click', editProjectName);
        function editProjectName() {
            currentProjectNameDisplay.style.display = 'none';
            editProjectNameInput.style.display = 'inline-block';
            editProjectNameInput.focus();
            editProjectNameInput.select();
            if (!editProjectNameInput._eventListenersAdded) {
                editProjectNameInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        saveProjectName();
                    }
                });
                editProjectNameInput.addEventListener('blur', saveProjectName);
                editProjectNameInput.addEventListener('change', saveProjectName);
                editProjectNameInput._eventListenersAdded = true;
            }
        }
        function saveProjectName() {
            const newName = editProjectNameInput.value.trim();
            if (newName !== '' && newName !== projects[currentProjectId].name) {
                projects[currentProjectId].name = newName;
                saveAllProjects();
                updateProjectDisplay();
            }
            currentProjectNameDisplay.style.display = 'inline-block';
            editProjectNameInput.style.display = 'none';
        }
        function renderStageNavigation() {
            stageNavContainer.innerHTML = '';
            
            // Always ensure we have exactly 6 stages (stage1-stage6) in order
            const expectedStages = ['stage1', 'stage2', 'stage3', 'stage4', 'stage5', 'stage6'];
            const finalStageOrder = expectedStages.filter(stageId => stagesConfig[stageId]);
            
            const leftSideStages = finalStageOrder.slice(0, 3);
            const rightSideStages = finalStageOrder.slice(3, 6);
            const leftDiv = document.createElement('div');
            const rightDiv = document.createElement('div');
            leftSideStages.forEach(stageId => {
                const stage = stagesConfig[stageId];
                if (!stage) return; // Skip if stage config is missing
                const button = document.createElement('button');
                button.className = 'stage-nav-button';
                button.textContent = `${stage.longName}`;
                button.onclick = () => switchStage(stageId);
                if (stageId === currentStageId) {
                    button.classList.add('active');
                }
                leftDiv.appendChild(button);
            });
            const wineIconContainer = document.createElement('div');
            wineIconContainer.className = 'wine-icon-container';
            const wineIconLink = document.createElement('a');
            wineIconLink.href = "#";
            wineIconLink.onclick = (e) => { e.preventDefault(); };
            const wineIconImg = document.createElement('img');
            wineIconImg.src = "image_00b206.png";
            wineIconImg.alt = "Wine Icon";
            wineIconLink.appendChild(wineIconImg);
            wineIconContainer.appendChild(wineIconLink);
            rightSideStages.forEach(stageId => {
                const stage = stagesConfig[stageId];
                if (!stage) return; // Skip if stage config is missing
                const button = document.createElement('button');
                button.className = 'stage-nav-button';
                button.textContent = `${stage.longName}`;
                button.onclick = () => switchStage(stageId);
                if (stageId === currentStageId) {
                    button.classList.add('active');
                }
                rightDiv.appendChild(button);
            });
            stageNavContainer.appendChild(leftDiv);
            stageNavContainer.appendChild(wineIconContainer);
            stageNavContainer.appendChild(rightDiv);
        }
        function switchStage(stageId) {
            currentStageId = stageId;
            localStorage.setItem('currentStageId', currentStageId);
            renderStageNavigation();
            loadCurrentStageContent();
        }
        // Expose switchStage globally for the stage-nav-fix module
        window.switchStage = switchStage;
        function loadCurrentStageContent() {
            if (projects[currentProjectId].isClosed) {
                alert('הפרויקט סגור. פתח אותו כדי לעבוד עליו.');
                return;
            }
            const stageConfig = stagesConfig[currentStageId];
            if (!stageConfig || currentStageId === 'wineDetails') {
                console.error("Invalid or special stage for main content:", currentStageId);
                currentStageId = Object.keys(stagesConfig).find(id => id !== 'wineDetails');
                if (!currentStageId) {
                    return;
                }
                localStorage.setItem('currentStageId', currentStageId);
                renderStageNavigation();
                loadCurrentStageContent();
                return;
            }
            fixedDashboardStageName.textContent = `${stageConfig.longName}`;
            currentStageInputSection.innerHTML = '';
            
            // Render predefined metrics
            for (const metricId in stageConfig.metrics) {
                const metric = stageConfig.metrics[metricId];
                const inputGroup = document.createElement('div');
                inputGroup.className = 'input-group';
                let inputElementHTML = '';
                if (metric.type === 'select') {
                    inputElementHTML = `<select id="${metricId}Input">`;
                    inputElementHTML += `<option value="" disabled selected>${metric.placeholder}</option>`;
                    metric.options.forEach(option => {
                        inputElementHTML += `<option value="${option}">${option}</option>`;
                    });
                    inputElementHTML += `<option value="other_input_field">אחר...</option>`;
                    inputElementHTML += `</select>`;
                    inputElementHTML += `<input type="text" id="${metricId}OtherInput" placeholder="הכנס זן אחר" style="display:none; margin-top: 5px;">`;
                } else if (metric.type === 'date') {
                    inputElementHTML = `<input type="text" id="${metricId}Input" placeholder="${metric.placeholder || ''}" readonly>`;
                } else {
                    const inputType = metric.type === 'number' ? 'text' : metric.type;
                    inputElementHTML = `<input type="${inputType}" data-input-kind="${metric.type}" id="${metricId}Input" ${metric.type === 'number' ? `inputmode="decimal"` : ''} placeholder="${metric.placeholder || ''}">`;
                }
                inputGroup.innerHTML = `
                    <label for="${metricId}Input">${metric.name}:</label>
                    ${inputElementHTML}
                    <button onclick="updateMetricValue('${currentStageId}', '${metricId}')">עדכן</button>
                `;
                currentStageInputSection.appendChild(inputGroup);
                if (metric.type === 'select') {
                    const selectElement = document.getElementById(`${metricId}Input`);
                    const otherInput = document.getElementById(`${metricId}OtherInput`);
                    if (selectElement && otherInput) {
                        selectElement.addEventListener('change', () => {
                            if (selectElement.value === 'other_input_field') {
                                otherInput.style.display = 'block';
                                otherInput.focus();
                            } else {
                                otherInput.style.display = 'none';
                                otherInput.value = '';
                            }
                        });
                    }
                }
                if (metric.type === 'date') {
                    const dateInput = document.getElementById(`${metricId}Input`);
                    if (dateInput) {
                        dateInput.addEventListener('click', () => {
                            showDatePicker(dateInput.value, (selectedDate) => {
                                dateInput.value = selectedDate;
                            });
                        });
                    }
                }
            }
            
            // Render custom metrics with the same styling
            for (const metricId in stageConfig.customMetrics) {
                const metric = stageConfig.customMetrics[metricId];
                const inputGroup = document.createElement('div');
                inputGroup.className = 'input-group';
                let inputElementHTML = '';
                if (metric.type === 'date') {
                    inputElementHTML = `<input type="text" id="${metricId}Input" placeholder="${metric.placeholder || ''}" readonly>`;
                } else {
                    const inputType = metric.type === 'number' ? 'text' : metric.type;
                    inputElementHTML = `<input type="${inputType}" data-input-kind="${metric.type}" id="${metricId}Input" ${metric.type === 'number' ? `inputmode="decimal"` : ''} placeholder="${metric.placeholder || ''}">`;
                }
                inputGroup.innerHTML = `
                    <label for="${metricId}Input">${metric.name}:</label>
                    ${inputElementHTML}
                    <button onclick="updateMetricValue('${currentStageId}', '${metricId}')">עדכן</button>
                `;
                currentStageInputSection.appendChild(inputGroup);
                if (metric.type === 'date') {
                    const dateInput = document.getElementById(`${metricId}Input`);
                    if (dateInput) {
                        dateInput.addEventListener('click', () => {
                            showDatePicker(dateInput.value, (selectedDate) => {
                                dateInput.value = selectedDate;
                            });
                        });
                    }
                }
            }
            // Render custom metrics with update option (no delete button here)
            if (stageConfig.customMetrics) {
                for (const metricId in stageConfig.customMetrics) {
                    const metric = stageConfig.customMetrics[metricId];
                    const inputGroup = document.createElement('div');
                    inputGroup.className = 'input-group';
                    const inputType = metric.type === 'number' ? 'text' : (metric.type || 'text');
                    const placeholder = metric.placeholder || '';
                    inputGroup.innerHTML = `
                        <label for="${metricId}Input">${metric.name}:</label>
                        <input type="${inputType}" data-input-kind="${metric.type || 'text'}" id="${metricId}Input" ${metric.type === 'number' ? `inputmode="decimal"` : ''} placeholder="${placeholder}">
                        <button onclick="updateMetricValue('${currentStageId}', '${metricId}')">עדכן</button>
                    `;
                    currentStageInputSection.appendChild(inputGroup);
                }
            }
            updateDashboardForCurrentStage();
            renderPreviousStageOverview();
            
            // Add autosave listeners for current stage inputs
            attachAutosaveListenersToStageInputs();
        }
        
        // WeakSet to track inputs with autosave listeners attached
        const autosaveListenersAttached = new WeakSet();
        
        /**
         * Attach autosave listeners to current stage input fields
         */
        function attachAutosaveListenersToStageInputs() {
            if (!currentStageInputSection) return;
            
            const inputGroups = currentStageInputSection.querySelectorAll('.input-group');
            inputGroups.forEach(group => {
                const input = group.querySelector('input[id$="Input"], select[id$="Input"]');
                if (!input) return;
                
                // Extract metricId from input id (remove "Input" suffix)
                const metricId = input.id.replace('Input', '');
                
                // Skip if already has autosave listener
                if (autosaveListenersAttached.has(input)) return;
                autosaveListenersAttached.add(input);
                
                // Add autosave on blur (when user leaves the field)
                input.addEventListener('blur', () => {
                    const value = input.value.trim();
                    if (value) {
                        // Trigger the existing update function
                        updateMetricValue(currentStageId, metricId);
                    }
                });
                
                // For select elements, also save on change
                if (input.tagName === 'SELECT') {
                    input.addEventListener('change', () => {
                        const value = input.value;
                        if (value && value !== 'other_input_field') {
                            updateMetricValue(currentStageId, metricId);
                        }
                    });
                }
            });
        }
        
        function updateMetricValue(stageId, metricId) {
            let inputElement;
            let value;
            // Check if it's a custom metric or predefined metric
            const metricConfig = stagesConfig[stageId].metrics[metricId] || stagesConfig[stageId].customMetrics[metricId];
            
            if (!metricConfig) {
                console.error('Metric not found:', metricId);
                return;
            }
            
            if (metricConfig.type === 'select') {
                inputElement = document.getElementById(`${metricId}Input`);
                if (inputElement.value === 'other_input_field') {
                    const otherInput = document.getElementById(`${metricId}OtherInput`);
                    value = otherInput.value.trim();
                } else {
                    value = inputElement.value;
                }
            } else {
                inputElement = document.getElementById(`${metricId}Input`);
                value = inputElement.value.trim();
            }
            
            // Accept both numbers and text
            // For number-type inputs, try to parse as number but allow text fallback
            if (metricConfig.type === 'number' && value !== '') {
                const numValue = parseFloat(value);
                // If it's a valid number, use it; otherwise keep as text
                if (!isNaN(numValue)) {
                    value = numValue;
                }
                // Allow text input even for number fields
            }
            
            if (value === '' || value === null || value === undefined) {
                alert('אנא הזן ערך.');
                return;
            }
            
            const timestamp = new Date().toLocaleString('he-IL', {
                year: 'numeric', month: 'numeric', day: 'numeric',
                hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
            });
            if (!projects[currentProjectId].stages[stageId] || !projects[currentProjectId].stages[stageId][metricId]) {
                if (!projects[currentProjectId].stages[stageId]) {
                    projects[currentProjectId].stages[stageId] = {};
                }
                projects[currentProjectId].stages[stageId][metricId] = [];
            }
            projects[currentProjectId].stages[stageId][metricId].push({ value, timestamp });
            saveAllProjects();
            if (metricConfig.type === 'select') {
                inputElement.value = "";
                const otherInput = document.getElementById(`${metricId}OtherInput`);
                if (otherInput) {
                    otherInput.value = '';
                    otherInput.style.display = 'none';
                }
            } else {
                inputElement.value = '';
            }
            updateDashboardForCurrentStage();
            renderPreviousStageOverview();
        }
        function updateDashboardForCurrentStage() {
            fixedDashboardGrid.innerHTML = '';
            const stageMetrics = stagesConfig[currentStageId].metrics;
            const customMetrics = stagesConfig[currentStageId].customMetrics;
            
            // Render predefined metrics
            for (const metricId in stageMetrics) {
                const metricConfig = stageMetrics[metricId];
                const currentEntries = projects[currentProjectId].stages[currentStageId][metricId];
                let displayValue = '--';
                if (currentEntries && currentEntries.length > 0) {
                    const lastValue = currentEntries[currentEntries.length - 1].value;
                    if (typeof lastValue === 'number' && metricConfig.precision != null) {
                        displayValue = lastValue.toFixed(metricConfig.precision);
                    } else {
                        displayValue = lastValue;
                    }
                }
                const dashboardItem = document.createElement('div');
                dashboardItem.className = 'dashboard-item';
                dashboardItem.setAttribute('onclick', `openHistoryModal('${currentStageId}', '${metricId}', '${metricConfig.name}')`);
                dashboardItem.innerHTML = `
                    <h3>${metricConfig.name}</h3>
                    <p>${displayValue}</p>
                `;
                fixedDashboardGrid.appendChild(dashboardItem);
            }
            
            // Render custom metrics with the same styling
            for (const metricId in customMetrics) {
                const metricConfig = customMetrics[metricId];
                const currentEntries = projects[currentProjectId].stages[currentStageId][metricId];
                let displayValue = '--';
                if (currentEntries && currentEntries.length > 0) {
                    const lastValue = currentEntries[currentEntries.length - 1].value;
                    if (typeof lastValue === 'number' && metricConfig.precision != null) {
                        displayValue = lastValue.toFixed(metricConfig.precision || 2);
                    } else {
                        displayValue = lastValue;
                    }
                }
                const dashboardItem = document.createElement('div');
                dashboardItem.className = 'dashboard-item';
                dashboardItem.setAttribute('onclick', `openHistoryModal('${currentStageId}', '${metricId}', '${metricConfig.name}')`);
                dashboardItem.innerHTML = `
                    <h3>${metricConfig.name}</h3>
                    <p>${displayValue}</p>
                `;
                fixedDashboardGrid.appendChild(dashboardItem);
            }
        }
        /**
         * Determine whether a metric is a custom metric (stage or wine details).
         * @param {string} sectionId stage identifier or 'wineDetails'
         * @param {string} metricId metric identifier to check
         * @returns {{isCustomStageMetric: boolean, isCustomWineMetric: boolean}}
         */
        function getCustomMetricFlags(sectionId, metricId) {
            const isCustomStageMetric = sectionId !== 'wineDetails'
                && stagesConfig[sectionId]?.customMetrics
                && Boolean(stagesConfig[sectionId].customMetrics[metricId]);
            const isCustomWineMetric = sectionId === 'wineDetails'
                && Array.isArray(projects[currentProjectId]?.wineDetails?.customProperties)
                && projects[currentProjectId].wineDetails.customProperties.some(prop => prop.id === metricId);
            return { isCustomStageMetric, isCustomWineMetric };
        }
        function openHistoryModal(sectionId, metricId, metricName) {
            currentMetricTypeForModal = { sectionId, metricId };
            modalTitle.textContent = `היסטוריית ${metricName} (${stagesConfig[sectionId].name})`;
            historyList.innerHTML = '';
            modalGraphSvg.innerHTML = '';
            let metricConfig;
            let historyEntries;
            if (sectionId === 'wineDetails') {
                metricConfig = stagesConfig.wineDetails.metrics[metricId];
                if (metricConfig) {
                    historyEntries = projects[currentProjectId].wineDetails[metricId];
                } else {
                    const customProp = projects[currentProjectId].wineDetails.customProperties.find(prop => prop.id === metricId);
                    if (customProp) {
                        historyEntries = customProp.history;
                        metricConfig = { name: customProp.name, type: 'text' };
                        if (historyEntries.every(entry => typeof entry.value === 'number')) {
                            metricConfig.type = 'number';
                            metricConfig.precision = 2;
                        }
                    }
                }
            } else {
                // Check predefined metrics first, then custom metrics
                metricConfig = stagesConfig[sectionId].metrics[metricId] || stagesConfig[sectionId].customMetrics[metricId];
                historyEntries = projects[currentProjectId].stages[sectionId][metricId];
            }
            const { isCustomStageMetric, isCustomWineMetric } = getCustomMetricFlags(sectionId, metricId);
            if (deleteMetricBtn) {
                deleteMetricBtn.style.display = (isCustomStageMetric || isCustomWineMetric) ? 'inline-block' : 'none';
            }
            const precision = metricConfig ? metricConfig.precision : null;
            // Check if we have any numeric values for graphing
            const hasNumericValues = historyEntries && historyEntries.length > 0 && 
                historyEntries.some(e => typeof e.value === 'number' && !isNaN(e.value));
            
            if (metricConfig && hasNumericValues) {
                modalGraphSvg.style.display = 'block';
                historyModal.style.display = 'flex';
                setTimeout(() => {
                    drawModalGraph(historyEntries, precision);
                }, 50);
            } else {
                modalGraphSvg.style.display = 'none';
                historyModal.style.display = 'flex';
            }
            if (historyEntries && historyEntries.length > 0) {
                historyEntries.slice().reverse().forEach((entry, index) => {
                    const originalIndex = historyEntries.length - 1 - index;
                    const listItem = document.createElement('li');
                    let displayValue;
                    if (typeof entry.value === 'number' && metricConfig && metricConfig.precision != null) {
                        displayValue = entry.value.toFixed(precision);
                    } else {
                        displayValue = entry.value;
                    }
                    listItem.innerHTML = `
                        <strong>${displayValue}</strong>
                        <span class="timestamp">${entry.timestamp}</span>
                        <button class="undo-button" onclick="undoUpdate('${sectionId}', '${metricId}', ${originalIndex})">בטל</button>
                    `;
                    historyList.appendChild(listItem);
                });
            } else {
                const listItem = document.createElement('li');
                listItem.textContent = 'אין נתונים היסטוריים זמינים.';
                historyList.appendChild(listItem);
            }
        }
        function drawModalGraph(entries, precision) {
            modalGraphSvg.innerHTML = '';
            
            // Filter only numeric entries for graph
            const numericEntries = entries.filter(e => typeof e.value === 'number' && !isNaN(e.value));
            
            if (numericEntries.length < 1) {
                return;
            }
            const svgWidth = modalGraphSvg.clientWidth;
            const svgHeight = modalGraphSvg.clientHeight;
            const paddingTop = 25;
            const paddingBottom = 40;
            const paddingLeft = 40;
            const paddingRight = 10;
            const graphWidth = svgWidth - paddingLeft - paddingRight;
            const graphHeight = svgHeight - paddingTop - paddingBottom;
            let values = numericEntries.map(e => e.value);
            let minValue = Math.min(...values);
            let maxValue = Math.max(...values);
            let averageValue = values.reduce((sum, val) => sum + val, 0) / values.length;
            if (numericEntries.length === 1 || minValue === maxValue) {
                const buffer = (values[0] * 0.1) || 1;
                minValue = values[0] - buffer;
                maxValue = values[0] + buffer;
                if (minValue === maxValue) {
                     minValue -= 0.5;
                     maxValue += 0.5;
                }
            }
            let comparisonEntries = null;
            if (comparisonProjectId && projects[comparisonProjectId]) {
                let compHistoryEntries;
                if (currentMetricTypeForModal.sectionId === 'wineDetails') {
                    compHistoryEntries = projects[comparisonProjectId].wineDetails[currentMetricTypeForModal.metricId];
                } else {
                    compHistoryEntries = projects[comparisonProjectId].stages[currentMetricTypeForModal.sectionId][currentMetricTypeForModal.metricId];
                }
                if (compHistoryEntries && compHistoryEntries.length > 0) {
                    // Filter numeric values from comparison entries too
                    const compNumericEntries = compHistoryEntries.filter(e => typeof e.value === 'number' && !isNaN(e.value));
                    if (compNumericEntries.length > 0) {
                        comparisonEntries = compNumericEntries;
                        const compValues = compNumericEntries.map(e => e.value);
                        minValue = Math.min(minValue, ...compValues);
                        maxValue = Math.max(maxValue, ...compValues);
                        values = values.concat(compValues);
                        averageValue = values.reduce((sum, val) => sum + val, 0) / values.length;
                    }
                }
            }
            const valueRange = maxValue - minValue;
            const xScale = (index) => paddingLeft + (index / (numericEntries.length - 1 || 1)) * graphWidth;
            const yScale = (value) => graphHeight - ((value - minValue) / valueRange) * graphHeight + paddingTop;
            const numYLabels = 3;
            for (let i = 0; i < numYLabels; i++) {
                const valueAtY = minValue + (i / (numYLabels - 1)) * valueRange;
                const yPos = yScale(valueAtY);
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', paddingLeft);
                line.setAttribute('y1', yPos);
                line.setAttribute('x2', svgWidth - paddingRight);
                line.setAttribute('y2', yPos);
                line.classList.add('modal-graph-grid-line');
                modalGraphSvg.appendChild(line);
                const textY = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                textY.setAttribute('x', paddingLeft - 5);
                textY.setAttribute('y', yPos + 3);
                textY.classList.add('modal-graph-label-y');
                textY.textContent = valueAtY.toFixed(precision);
                modalGraphSvg.appendChild(textY);
            }
            let linePath = '';
            let areaPath = `M ${paddingLeft} ${yScale(minValue)}`;
            numericEntries.forEach((entry, i) => {
                const x = xScale(i);
                const y = yScale(entry.value);
                if (i === 0) {
                    linePath += `M ${x} ${y}`;
                } else {
                    linePath += `L ${x} ${y}`;
                }
                areaPath += `L ${x} ${y}`;
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', 5);
                circle.classList.add('modal-graph-point');
                circle.setAttribute('data-value', entry.value.toFixed(precision));
                circle.setAttribute('data-timestamp', entry.timestamp);
                modalGraphSvg.appendChild(circle);
                const datePart = entry.timestamp.split(',')[0];
                const timePart = entry.timestamp.split(',')[1] ? entry.timestamp.split(',')[1].trim() : '';
                const interval = Math.ceil(numericEntries.length / 5);
                if (numericEntries.length <= 2 || i % interval === 0 || i === numericEntries.length - 1) {
                    const textX = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    textX.setAttribute('x', x);
                    textX.setAttribute('y', svgHeight - paddingBottom + 10);
                    textX.classList.add('modal-graph-label-x');
                    const tspanDate = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                    tspanDate.setAttribute('x', x);
                    tspanDate.setAttribute('dy', '0em');
                    tspanDate.textContent = datePart;
                    textX.appendChild(tspanDate);
                    if (timePart) {
                        const tspanTime = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                        tspanTime.setAttribute('x', x);
                        tspanTime.setAttribute('dy', '1.2em');
                        tspanTime.textContent = timePart;
                        textX.appendChild(tspanTime);
                    }
                    textX.setAttribute('transform', `rotate(-45 ${x}, ${svgHeight - paddingBottom + 10})`);
                    modalGraphSvg.appendChild(textX);
                }
            });
            areaPath += `L ${xScale(numericEntries.length - 1)} ${yScale(minValue)} L ${paddingLeft} ${yScale(minValue)} Z`;
            const area = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            area.setAttribute('d', areaPath);
            area.classList.add('modal-graph-area-path');
            modalGraphSvg.appendChild(area);
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', linePath);
            path.classList.add('modal-graph-line-path');
            modalGraphSvg.appendChild(path);
            const pathLength = path.getTotalLength();
            path.style.strokeDasharray = `${pathLength} ${pathLength}`;
            path.style.strokeDashoffset = pathLength;
            setTimeout(() => {
                path.style.strokeDashoffset = 0;
            }, 100);
            if (comparisonEntries) {
                let compLinePath = '';
                let compAreaPath = `M ${paddingLeft} ${yScale(minValue)}`;
                comparisonEntries.forEach((entry, i) => {
                    const x = paddingLeft + (i / (comparisonEntries.length - 1 || 1)) * graphWidth;
                    const y = yScale(entry.value);
                    if (i === 0) {
                        compLinePath += `M ${x} ${y}`;
                    } else {
                        compLinePath += `L ${x} ${y}`;
                    }
                    compAreaPath += `L ${x} ${y}`;
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', 4);
                    circle.setAttribute('fill', '#FF6347');
                    circle.setAttribute('stroke', '#fff');
                    circle.setAttribute('stroke-width', '2');
                    circle.setAttribute('data-value', entry.value.toFixed(precision));
                    circle.setAttribute('data-timestamp', entry.timestamp);
                    modalGraphSvg.appendChild(circle);
                });
                compAreaPath += `L ${paddingLeft + ((comparisonEntries.length - 1) / (comparisonEntries.length - 1 || 1)) * graphWidth} ${yScale(minValue)} L ${paddingLeft} ${yScale(minValue)} Z`;
                const compArea = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                compArea.setAttribute('d', compAreaPath);
                compArea.setAttribute('fill', 'rgba(255, 99, 71, 0.2)');
                compArea.setAttribute('opacity', '0.8');
                modalGraphSvg.appendChild(compArea);
                const compPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                compPath.setAttribute('d', compLinePath);
                compPath.setAttribute('fill', 'none');
                compPath.setAttribute('stroke', '#FF6347');
                compPath.setAttribute('stroke-width', '3');
                modalGraphSvg.appendChild(compPath);
            }
            const avgY = yScale(averageValue);
            const avgLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            avgLine.setAttribute('x1', paddingLeft);
            avgLine.setAttribute('y1', avgY);
            avgLine.setAttribute('x2', svgWidth - paddingRight);
            avgLine.setAttribute('y2', avgY);
            avgLine.classList.add('modal-graph-average-line');
            modalGraphSvg.appendChild(avgLine);
            const avgLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            avgLabel.setAttribute('x', svgWidth - paddingRight + 5);
            avgLabel.setAttribute('y', avgY + 3);
            avgLabel.classList.add('modal-graph-average-label');
            avgLabel.textContent = `ממוצע: ${averageValue.toFixed(precision)}`;
            modalGraphSvg.appendChild(avgLabel);
            const zoom = d3.zoom().scaleExtent([0.5, 5]).on('zoom', (event) => {
                const transform = event.transform;
                modalGraphSvg.style.transform = `translate(${transform.x}px, ${transform.y}px) scale(${transform.k})`;
            });
            d3.select(modalGraphSvg).call(zoom);
        }
        function closeHistoryModal() {
            historyModal.style.display = 'none';
            comparisonProjectId = null;
        }
        async function handleDeleteMetric() {
            if (!currentMetricTypeForModal) return;
            const { sectionId, metricId } = currentMetricTypeForModal;
            const { isCustomStageMetric, isCustomWineMetric } = getCustomMetricFlags(sectionId, metricId);
            if (!isCustomStageMetric && !isCustomWineMetric) {
                alert('ניתן למחוק רק מדדים מותאמים אישית.');
                return;
            }
            const confirmed = await showConfirmation(
                'האם אתה בטוח שברצונך למחוק מדד זה? פעולה זו תמחק גם את ההיסטוריה שלו.',
                'מחיקת מדד'
            );
            if (!confirmed) {
                return;
            }
            if (isCustomWineMetric) {
                deleteCustomProperty(metricId, true);
            } else {
                deleteCustomMetric(sectionId, metricId, true);
            }
            closeHistoryModal();
            updateDashboardForCurrentStage();
            renderPreviousStageOverview();
        }
        async function undoUpdate(sectionId, metricId, indexToRemove) {
            const confirmed = await showConfirmation(
                'האם אתה בטוח שברצונך לבטל את העדכון הזה?',
                'ביטול עדכון'
            );
            if (!confirmed) {
                return;
            }
            let metricDataArray;
            if (sectionId === 'wineDetails') {
                const predefinedMetricConfig = stagesConfig.wineDetails.metrics[metricId];
                if (predefinedMetricConfig) {
                    metricDataArray = projects[currentProjectId].wineDetails[metricId];
                } else {
                    const customProp = projects[currentProjectId].wineDetails.customProperties.find(prop => prop.id === metricId);
                    if (customProp) {
                        metricDataArray = customProp.history;
                    } else {
                        console.error("Attempted to undo for non-existent custom property or metric:", metricId);
                        return;
                    }
                }
            } else {
                metricDataArray = projects[currentProjectId].stages[sectionId][metricId];
            }
            if (metricDataArray) {
                metricDataArray.splice(indexToRemove, 1);
                saveAllProjects();
                if (sectionId === 'wineDetails') {
                    updateProjectDetailsCard();
                } else {
                    updateDashboardForCurrentStage();
                    renderPreviousStageOverview();
                }
                if (currentMetricTypeForModal.sectionId === sectionId && currentMetricTypeForModal.metricId === metricId) {
                    const metricDisplayName = (sectionId === 'wineDetails' && !stagesConfig.wineDetails.metrics[metricId])
                                            ? projects[currentProjectId].wineDetails.customProperties.find(prop => prop.id === metricId).name
                                            : stagesConfig[sectionId].metrics[metricId].name;
                    openHistoryModal(sectionId, metricId, metricDisplayName);
                }
            } else {
                console.warn(`Attempted to undo for non-existent path: project: ${currentProjectId}, stage/section: ${sectionId}, metric: ${metricId}`);
                alert("שגיאה: לא ניתן לבטל. ייתכן שהנתונים אינם קיימים.");
            }
        }
        function openFinanceModal() {
            if (!ensureFinancePermission()) {
                return;
            }
            if (projects[currentProjectId].isClosed) {
                alert('הפרויקט סגור. פתח אותו כדי לנהל כספים.');
                return;
            }
            closeSidebar();
            document.querySelector('.container').style.display = 'none';
            document.querySelector('.top-section-wrapper').style.display = 'none';
            fixedDashboardSection.style.display = 'none';
            financeModal.style.display = 'flex';
            renderFinanceList();
        }
        function closeFinanceModal() {
            financeModal.style.display = 'none';
            showMainContent();
        }
        function addFinanceEntry(type) {
            if (!ensureFinancePermission()) {
                return;
            }
            const amount = parseFloat(financeAmountInput.value);
            const notes = financeNotesInput.value.trim();
            if (isNaN(amount) || amount <= 0) {
                alert('אנא הזן סכום חוקי (חיובי) עבור התנועה.');
                return;
            }
            const timestamp = new Date().toLocaleString('he-IL', {
                year: 'numeric', month: 'numeric', day: 'numeric',
                hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
            });
            projects[currentProjectId].finance.push({ id: Date.now(), type, amount, notes, timestamp });
            saveAllProjects();
            financeAmountInput.value = '';
            financeNotesInput.value = '';
            renderFinanceList();
        }
        function renderFinanceList() {
            financeList.innerHTML = '';
            let balance = 0;
            const sortedEntries = projects[currentProjectId].finance.slice().sort((a, b) => {
                const parseDateString = (ts) => {
                    const parts = ts.match(/(\d{2})\/(\d{2})\/(\d{4})(?:, (\d{2}):(\d{2}):(\d{2}))?/);
                    if (parts) {
                        const year = parseInt(parts[3], 10);
                        const month = parseInt(parts[2], 10) - 1;
                        const day = parseInt(parts[1], 10);
                        const hour = parseInt(parts[4] || 0, 10);
                        const minute = parseInt(parts[5] || 0, 10);
                        const second = parseInt(parts[6] || 0, 10);
                        return new Date(year, month, day, hour, minute, second);
                    }
                    return new Date(ts);
                };
                const dateA = parseDateString(a.timestamp);
                const dateB = parseDateString(b.timestamp);
                return dateB.getTime() - dateA.getTime();
            });
            sortedEntries.forEach(entry => {
                const listItem = document.createElement('li');
                listItem.setAttribute('data-finance-id', entry.id);
                const displayAmount = (entry.type === 'expense' ? '-' : '+') + entry.amount.toFixed(2);
                const amountClass = entry.type;
                listItem.innerHTML = `
                    <div class="finance-item-details">
                        <span class="amount ${amountClass}">${displayAmount} ₪</span>
                        <div class="notes">${entry.notes || 'אין הערות'}</div>
                        <span class="timestamp" style="font-size:0.8em; color:var(--light-text-color);">${entry.timestamp}</span>
                    </div>
                    <div class="finance-item-actions">
                        <button onclick="editFinanceEntry(${entry.id})">ערוך</button>
                        <button class="delete" onclick="deleteFinanceEntry(${entry.id})">מחק</button>
                    </div>
                `;
                financeList.appendChild(listItem);
                if (entry.type === 'income') {
                    balance += entry.amount;
                } else {
                    balance -= entry.amount;
                }
            });
            if (financeList.children.length === 0) {
                const listItem = document.createElement('li');
                listItem.textContent = 'אין תנועות כספיות תואמות בפרויקט זה.';
                financeList.appendChild(listItem);
            }
            currentBalanceDisplay.textContent = balance.toFixed(2);
            currentBalanceDisplay.classList.remove('positive', 'negative');
            if (balance > 0) {
                currentBalanceDisplay.classList.add('positive');
            } else if (balance < 0) {
                currentBalanceDisplay.classList.add('negative');
            }
        }
        function editFinanceEntry(id) {
            const entry = projects[currentProjectId].finance.find(e => e.id === id);
            if (!entry) return;
            editingFinanceEntryId = id;
            if (financeEditAmountInput) {
                financeEditAmountInput.value = entry.amount;
            }
            if (financeEditNotesInput) {
                financeEditNotesInput.value = entry.notes || '';
            }
            if (financeEditModal) {
                financeEditModal.style.display = 'flex';
                setTimeout(() => financeEditAmountInput?.focus(), 0);
            }
        }
        async function deleteFinanceEntry(id) {
            if (!ensureFinancePermission()) {
                return;
            }
            const confirmed = await showConfirmation(
                'האם אתה בטוח שברצונך למחוק תנועה כספית זו?',
                'מחיקת תנועה'
            );
            if (confirmed) {
                const initialLength = projects[currentProjectId].finance.length;
                projects[currentProjectId].finance = projects[currentProjectId].finance.filter(entry => entry.id !== id);
                if (projects[currentProjectId].finance.length < initialLength) {
                    saveAllProjects();
                    renderFinanceList();
                }
            }
        }
        function saveFinanceEdit() {
            if (!ensureFinancePermission()) {
                return;
            }
            if (editingFinanceEntryId === null) {
                closeFinanceEditModal();
                return;
            }
            const entry = projects[currentProjectId].finance.find(e => e.id === editingFinanceEntryId);
            if (!entry) {
                closeFinanceEditModal();
                return;
            }
            const newAmount = parseFloat(financeEditAmountInput ? financeEditAmountInput.value : '');
            if (isNaN(newAmount) || newAmount <= 0) {
                alert('הסכום שהוזן אינו חוקי.');
                return;
            }
            const newNotes = financeEditNotesInput ? financeEditNotesInput.value.trim() : '';
            entry.amount = newAmount;
            entry.notes = newNotes;
            saveAllProjects();
            renderFinanceList();
            closeFinanceEditModal();
        }
        function closeFinanceEditModal() {
            if (financeEditModal) {
                financeEditModal.style.display = 'none';
            }
            editingFinanceEntryId = null;
            if (financeEditAmountInput) financeEditAmountInput.value = '';
            if (financeEditNotesInput) financeEditNotesInput.value = '';
        }
        function openCurrentProjectFinanceReportModal() {
            if (!ensureFinancePermission()) {
                return;
            }
            closeSidebar();
            document.querySelector('.container').style.display = 'none';
            document.querySelector('.top-section-wrapper').style.display = 'none';
            fixedDashboardSection.style.display = 'none';
            currentProjectFinanceReportModal.style.display = 'flex';
            renderCurrentProjectFinanceReport();
        }
        function closeCurrentProjectFinanceReportModal() {
            currentProjectFinanceReportModal.style.display = 'none';
            showMainContent();
        }
        function renderCurrentProjectFinanceReport() {
            let totalIncome = 0;
            let totalExpense = 0;
            let totalBalance = 0;
            currentProjectFinanceReportTableBody.innerHTML = '';
            const sortedEntries = projects[currentProjectId].finance.slice().sort((a, b) => {
                const parseDateString = (ts) => {
                    const parts = ts.match(/(\d{2})\/(\d{2})\/(\d{4})(?:, (\d{2}):(\d{2}):(\d{2}))?/);
                    if (parts) {
                        const year = parseInt(parts[3], 10);
                        const month = parseInt(parts[2], 10) - 1;
                        const day = parseInt(parts[1], 10);
                        const hour = parseInt(parts[4] || 0, 10);
                        const minute = parseInt(parts[5] || 0, 10);
                        const second = parseInt(parts[6] || 0, 10);
                        return new Date(year, month, day, hour, minute, second);
                    }
                    return new Date(ts);
                };
                const dateA = parseDateString(a.timestamp);
                const dateB = parseDateString(b.timestamp);
                return dateA.getTime() - dateB.getTime();
            });
            sortedEntries.forEach(entry => {
                const row = document.createElement('tr');
                const typeText = entry.type === 'income' ? 'הכנסה' : 'הוצאה';
                const amountText = entry.amount.toFixed(2) + ' ₪';
                row.innerHTML = `
                    <td>${entry.timestamp.split(',')[0]}</td>
                    <td>${typeText}</td>
                    <td>${amountText}</td>
                    <td>${entry.notes || 'אין הערות'}</td>
                `;
                currentProjectFinanceReportTableBody.appendChild(row);
                if (entry.type === 'income') {
                    totalIncome += entry.amount;
                } else {
                    totalExpense += entry.amount;
                }
            });
            totalBalance = totalIncome - totalExpense;
            currentProjectTotalIncomeDisplay.textContent = totalIncome.toFixed(2);
            currentProjectTotalExpenseDisplay.textContent = totalExpense.toFixed(2);
            currentProjectTotalBalanceDisplay.textContent = totalBalance.toFixed(2);
            currentProjectTotalBalanceDisplay.classList.remove('positive', 'negative');
            if (totalBalance > 0) {
                currentProjectTotalBalanceDisplay.classList.add('positive');
            } else if (totalBalance < 0) {
                currentProjectTotalBalanceDisplay.classList.add('negative');
            }
        }
        function openGlobalFinanceReportModal() {
            if (!ensureFinancePermission()) {
                return;
            }
            closeSidebar();
            document.querySelector('.container').style.display = 'none';
            document.querySelector('.top-section-wrapper').style.display = 'none';
            fixedDashboardSection.style.display = 'none';
            globalFinanceReportModal.style.display = 'flex';
            renderGlobalFinanceReport();
        }
        function closeGlobalFinanceReportModal() {
            globalFinanceReportModal.style.display = 'none';
            showMainContent();
        }
        function renderGlobalFinanceReport() {
            let globalTotalIncome = 0;
            let globalTotalExpense = 0;
            let globalBalance = 0;
            globalFinanceProjectsDetails.innerHTML = '';
            const sortedProjectIds = Object.keys(projects).sort((a,b) => projects[a].name.localeCompare(projects[b].name));
            sortedProjectIds.forEach(projectId => {
                const project = projects[projectId];
                let projectIncome = 0;
                let projectExpense = 0;
                let projectBalance = 0;
                project.finance.forEach(entry => {
                    if (entry.type === 'income') {
                        projectIncome += entry.amount;
                    } else {
                        projectExpense += entry.amount;
                    }
                });
                projectBalance = projectIncome - projectExpense;
                globalTotalIncome += projectIncome;
                globalTotalExpense += projectExpense;
                globalBalance += projectBalance;
                const projectSection = document.createElement('div');
                projectSection.className = 'global-finance-project-section';
                projectSection.innerHTML = `
                    <h4>${project.name}</h4>
                    <p>הכנסות: <span style="color:#4CAF50;">${projectIncome.toFixed(2)}</span> ₪</p>
                    <p>הוצאות: <span style="color:#F44336;">${projectExpense.toFixed(2)}</span> ₪</p>
                    <p>יתרה: <span class="project-balance ${projectBalance >= 0 ? 'positive' : 'negative'}">${projectBalance.toFixed(2)}</span> ₪</p>
                `;
                globalFinanceProjectsDetails.appendChild(projectSection);
            });
            globalTotalIncomeDisplay.textContent = globalTotalIncome.toFixed(2);
            globalTotalExpenseDisplay.textContent = globalTotalExpense.toFixed(2);
            globalTotalBalanceDisplay.textContent = globalBalance.toFixed(2);
            globalTotalBalanceDisplay.classList.remove('positive', 'negative');
            if (globalBalance > 0) {
                globalTotalBalanceDisplay.classList.add('positive');
            } else if (globalBalance < 0) {
                globalTotalBalanceDisplay.classList.add('negative');
            }
        }
        function openFinanceYearlyModal() {
            if (!ensureFinancePermission()) {
                return;
            }
            closeSidebar();
            document.querySelector('.container').style.display = 'none';
            document.querySelector('.top-section-wrapper').style.display = 'none';
            fixedDashboardSection.style.display = 'none';
            financeYearlyModal.style.display = 'flex';
            yearlyReportContent.style.display = 'none';
        }
        function closeFinanceYearlyModal() {
            financeYearlyModal.style.display = 'none';
            showMainContent();
        }
        function generateYearlyReport() {
            const selectedYear = yearSelect.value;
            if (!selectedYear) {
                alert('אנא בחר שנה.');
                return;
            }
            yearlyReportContent.style.display = 'block';
            let yearlyTotalIncome = 0;
            let yearlyTotalExpense = 0;
            let yearlyBalance = 0;
            yearlyFinanceProjectsDetails.innerHTML = '';
            const filteredProjects = Object.keys(projects).filter(projectId => {
                const project = projects[projectId];
                const vintageYearEntries = project.wineDetails.vintageYear;
                if (vintageYearEntries && vintageYearEntries.length > 0) {
                    const latestYear = vintageYearEntries[vintageYearEntries.length - 1].value;
                    return latestYear == selectedYear;
                }
                return false;
            });
            if (filteredProjects.length === 0) {
                yearlyFinanceProjectsDetails.innerHTML = '<p>אין פרויקטים בשנה זו.</p>';
                yearlyTotalIncomeDisplay.textContent = '0';
                yearlyTotalExpenseDisplay.textContent = '0';
                yearlyTotalBalanceDisplay.textContent = '0';
                return;
            }
            filteredProjects.forEach(projectId => {
                const project = projects[projectId];
                let projectIncome = 0;
                let projectExpense = 0;
                let projectBalance = 0;
                project.finance.forEach(entry => {
                    if (entry.type === 'income') {
                        projectIncome += entry.amount;
                    } else {
                        projectExpense += entry.amount;
                    }
                });
                projectBalance = projectIncome - projectExpense;
                yearlyTotalIncome += projectIncome;
                yearlyTotalExpense += projectExpense;
                yearlyBalance += projectBalance;
                const projectSection = document.createElement('div');
                projectSection.className = 'finance-yearly-project-section';
                projectSection.innerHTML = `
                    <h4>${project.name}</h4>
                    <p>הכנסות: <span style="color:#4CAF50;">${projectIncome.toFixed(2)}</span> ₪</p>
                    <p>הוצאות: <span style="color:#F44336;">${projectExpense.toFixed(2)}</span> ₪</p>
                    <p>יתרה: <span class="project-balance ${projectBalance >= 0 ? 'positive' : 'negative'}">${projectBalance.toFixed(2)}</span> ₪</p>
                `;
                yearlyFinanceProjectsDetails.appendChild(projectSection);
            });
            yearlyTotalIncomeDisplay.textContent = yearlyTotalIncome.toFixed(2);
            yearlyTotalExpenseDisplay.textContent = yearlyTotalExpense.toFixed(2);
            yearlyTotalBalanceDisplay.textContent = yearlyBalance.toFixed(2);
            yearlyTotalBalanceDisplay.classList.remove('positive', 'negative');
            if (yearlyBalance > 0) {
                yearlyTotalBalanceDisplay.classList.add('positive');
            } else if (yearlyBalance < 0) {
                yearlyTotalBalanceDisplay.classList.add('negative');
            }
        }
        function renderPreviousStageOverview() {
            stepCardsGrid.innerHTML = '';
            const stageOrder = Object.keys(stagesConfig).filter(id => id !== 'wineDetails');
            const currentStageIndex = stageOrder.indexOf(currentStageId);
            
            // Always show the container, even in harvest stage (stage1)
            stageOverviewContainer.style.display = 'block';
            
            if (currentStageIndex === 0) {
                // For harvest stage (first stage), show empty state message
                const emptyStateDiv = document.createElement('div');
                emptyStateDiv.className = 'stage-overview-empty-state';
                emptyStateDiv.innerHTML = `
                    <p>
                        <i class="fas fa-info-circle"></i>
                        אין עדיין נתונים משלבים קודמים. זהו השלב הראשון.
                    </p>
                `;
                stepCardsGrid.appendChild(emptyStateDiv);
                return;
            }
            
            for (let i = 0; i < currentStageIndex; i++) {
                const prevStageId = stageOrder[i];
                const prevStageConfig = stagesConfig[prevStageId];
                const prevStageData = projects[currentProjectId].stages[prevStageId];
                const card = document.createElement('div');
                card.className = 'step-preview-card';
                card.onclick = () => switchStage(prevStageId);
                card.innerHTML = `<h5>${prevStageConfig.longName}</h5>`;
                if (prevStageConfig.summaryMetrics) {
                    prevStageConfig.summaryMetrics.forEach(metricId => {
                        const metricConfig = prevStageConfig.metrics[metricId];
                        const entries = prevStageData[metricId];
                        let displayValue = '--';
                        if (entries && entries.length > 0) {
                            // Show the FIRST value instead of the last one
                            displayValue = metricConfig.type === 'number'
                                ? entries[0].value.toFixed(metricConfig.precision)
                                : entries[0].value;
                        }
                        card.innerHTML += `<p>${metricConfig.name}: <span class="summary-value">${displayValue}</span></p>`;
                    });
                } else {
                     card.innerHTML += `<p>אין מדדי סיכום לשלב זה.</p>`;
                }
                stepCardsGrid.appendChild(card);
            }
        }
        function updateProjectDetailsCard() {
            const projectData = projects[currentProjectId];
            const wineDetailsData = projectData.wineDetails || {};
            const addCustomPropertyBtn = projectDetailsCard.querySelector('.add-custom-property-btn');
            projectDetailsCard.querySelectorAll('.project-details-item').forEach(item => {
                if (!item.classList.contains('custom-property')) {
                    item.remove();
                } else if (!addCustomPropertyBtn.contains(item)) {
                    item.remove();
                }
            });
            const predefinedMetrics = ['wineName', 'vintageYear', 'grapeVariety', 'vineyardSource', 'generalNotes', 'harvestDate'];
            predefinedMetrics.forEach(metricId => {
                const metricConfig = stagesConfig.wineDetails.metrics[metricId];
                const item = document.createElement('div');
                item.className = 'project-details-item';
                item.setAttribute('data-metric-id', metricId);
                item.setAttribute('data-section', 'wineDetails');
                item.innerHTML = `
                    <span class="detail-label">${metricConfig.name}:</span>
                    <span class="detail-value editable">--</span>
                `;
                projectDetailsCard.insertBefore(item, addCustomPropertyBtn);
                attachEditListenerToDetailItem(item);
            });
            const getLatestWineDetailValue = (metricId, precision = null) => {
                let entries;
                if (stagesConfig.wineDetails.metrics[metricId]) {
                    entries = wineDetailsData[metricId];
                } else {
                    const customProp = wineDetailsData.customProperties.find(prop => prop.id === metricId);
                    entries = customProp ? customProp.history : null;
                }
                if (entries && entries.length > 0) {
                    const value = entries[entries.length - 1].value;
                    return (typeof value === 'number' && precision !== null) ? value.toFixed(precision) : value;
                }
                return '--';
            };
            predefinedMetrics.forEach(metricId => {
                const item = projectDetailsCard.querySelector(`[data-metric-id="${metricId}"]`);
                if (item) {
                    const displaySpan = item.querySelector('.detail-value');
                    const metricConfig = stagesConfig.wineDetails.metrics[metricId];
                    const precision = metricConfig.type === 'number' ? metricConfig.precision : null;
                    displaySpan.textContent = getLatestWineDetailValue(metricId, precision);
                }
            });
            if (projectData.wineDetails.customProperties) {
                projectData.wineDetails.customProperties.forEach(prop => {
                    const customPropertyItem = document.createElement('div');
                    customPropertyItem.className = 'project-details-item custom-property';
                    customPropertyItem.setAttribute('data-metric-id', prop.id);
                    customPropertyItem.setAttribute('data-section', 'wineDetails');
                    customPropertyItem.innerHTML = `
                        <span class="detail-label">${prop.name}:</span>
                        <span class="detail-value editable">${getLatestWineDetailValue(prop.id)}</span>
                        <button class="delete-custom-prop-btn" onclick="deleteCustomProperty('${prop.id}')">מחק</button>
                    `;
                    projectDetailsCard.insertBefore(customPropertyItem, addCustomPropertyBtn);
                    attachEditListenerToDetailItem(customPropertyItem);
                });
            }
        }
        function addCustomProperty() {
            if (projects[currentProjectId].isClosed) {
                alert('הפרויקט סגור. פתח אותו כדי לערוך.');
                return;
            }
            if (customPropertyModal && customPropertyNameInput) {
                customPropertyNameInput.value = '';
                customPropertyModal.style.display = 'flex';
                setTimeout(() => customPropertyNameInput.focus(), 0);
            }
        }
        function confirmAddCustomProperty() {
            if (projects[currentProjectId].isClosed) {
                alert('הפרויקט סגור. פתח אותו כדי לערוך.');
                return;
            }
            if (!ensureEditPermission()) {
                return;
            }
            const propName = customPropertyNameInput ? customPropertyNameInput.value.trim() : '';
            if (propName) {
                const propId = `customProp_${Date.now()}`;
                const newCustomProperty = {
                    id: propId,
                    name: propName,
                    history: []
                };
                projects[currentProjectId].wineDetails.customProperties.push(newCustomProperty);
                saveAllProjects();
                updateProjectDetailsCard();
                closeCustomPropertyModal();
            } else {
                alert('אנא הזן שם לשדה המותאם אישית.');
            }
        }
        async function deleteCustomProperty(propId, skipConfirm = false) {
            if (projects[currentProjectId].isClosed) {
                alert('הפרויקט סגור. פתח אותו כדי לערוך.');
                return;
            }
            if (!ensureEditPermission()) {
                return;
            }
            if (!skipConfirm) {
                const confirmed = await showConfirmation(
                    'האם אתה בטוח שברצונך למחוק שדה מותאם אישית זה?',
                    'מחיקת שדה'
                );
                if (!confirmed) {
                    return;
                }
            }
            projects[currentProjectId].wineDetails.customProperties = projects[currentProjectId].wineDetails.customProperties.filter(prop => prop.id !== propId);
            saveAllProjects();
            updateProjectDetailsCard();
        }
        function closeCustomPropertyModal() {
            if (customPropertyModal) {
                customPropertyModal.style.display = 'none';
            }
        }
        function attachEditListenerToDetailItem(item) {
            const displaySpan = item.querySelector('.detail-value');
            if (item._displaySpanClickHandler) {
                displaySpan.removeEventListener('click', item._displaySpanClickHandler);
            }
            const newClickHandler = () => {
                if (projects[currentProjectId].isClosed) {
                    alert('הפרויקט סגור. פתח אותו כדי לערוך.');
                    return;
                }
                if (!ensureEditPermission()) {
                    return;
                }
                if (currentEditableDetailElement && currentEditableDetailElement.displaySpan !== displaySpan) {
                    saveEditableDetail();
                }
                if (currentEditableDetailElement && currentEditableDetailElement.displaySpan === displaySpan) {
                    return;
                }
                const metricId = item.dataset.metricId;
                const section = item.dataset.section;
                let metricConfig;
                if (stagesConfig.wineDetails.metrics[metricId]) {
                    metricConfig = stagesConfig.wineDetails.metrics[metricId];
                } else {
                    const customProp = projects[currentProjectId].wineDetails.customProperties.find(prop => prop.id === metricId);
                    metricConfig = { type: 'text', name: item.querySelector('.detail-label').textContent.replace(':', '') };
                    if (customProp && customProp.history.every(entry => typeof entry.value === 'number')) {
                        metricConfig.type = 'number';
                        metricConfig.step = 'any';
                        metricConfig.precision = 2;
                    }
                }
                currentEditableDetailElement = { item, metricId, section, metricConfig, displaySpan: displaySpan };
                let currentValue = displaySpan.textContent === '--' ? '' : displaySpan.textContent;
                let inputElement;
                if (metricConfig.type === 'date') {
                    showDatePicker(currentValue, (selectedDate) => {
                        updateProjectDetailValue(section, metricId, selectedDate);
                        displaySpan.style.display = 'block';
                        currentEditableDetailElement = null;
                    });
                    displaySpan.style.display = 'none';
                    return;
                } else if (metricConfig.type === 'select') {
                    inputElement = document.createElement('select');
                    inputElement.innerHTML = `<option value="" disabled>--בחר--</option>`;
                    if (metricConfig.options) {
                        metricConfig.options.forEach(option => {
                            const optionElem = document.createElement('option');
                            optionElem.value = option;
                            optionElem.textContent = option;
                            if (option === currentValue) {
                                optionElem.selected = true;
                            }
                            inputElement.appendChild(optionElem);
                        });
                    }
                    const otherOption = document.createElement('option');
                    otherOption.value = 'other_input_field';
                    otherOption.textContent = 'אחר...';
                    inputElement.appendChild(otherOption);
                    const otherInput = document.createElement('input');
                    otherInput.type = 'text';
                    otherInput.placeholder = 'הכנס ערך אחר';
                    otherInput.style.display = 'none';
                    otherInput.style.marginTop = '5px';
                    inputElement.addEventListener('change', () => {
                        if (inputElement.value === 'other_input_field') {
                            otherInput.style.display = 'block';
                            otherInput.focus();
                        } else {
                            otherInput.style.display = 'none';
                            otherInput.value = '';
                        }
                    });
                    if (currentValue && metricConfig.options && !metricConfig.options.includes(currentValue) && currentValue !== '--') {
                        inputElement.value = 'other_input_field';
                        otherInput.value = currentValue;
                        otherInput.style.display = 'block';
                    }
                    item.appendChild(inputElement);
                    item.appendChild(otherInput);
                    inputElement.focus();
                    currentEditableDetailElement.inputElement = inputElement;
                    currentEditableDetailElement.otherInput = otherInput;
                    
                    // For select, we want to save immediately on change
                    inputElement.addEventListener('change', saveEditableDetail);
                    // For the "other" input, use similar delayed save as text inputs
                    let otherSaveScheduled = false;
                    const scheduleOtherSave = () => {
                        if (otherSaveScheduled) return;
                        otherSaveScheduled = true;
                        setTimeout(() => {
                            saveEditableDetail();
                            otherSaveScheduled = false;
                        }, 100);
                    };
                    otherInput.addEventListener('blur', scheduleOtherSave);
                } else {
                    inputElement = document.createElement('input');
                    inputElement.type = metricConfig.type === 'number' ? 'text' : metricConfig.type;
                    inputElement.value = currentValue;
                    inputElement.placeholder = metricConfig.placeholder || '';
                    item.appendChild(inputElement);
                    inputElement.focus();
                    inputElement.select();
                    currentEditableDetailElement.inputElement = inputElement;
                    
                    // Use a flag to prevent double-saving
                    let saveScheduled = false;
                    const scheduleSave = () => {
                        if (saveScheduled) return;
                        saveScheduled = true;
                        // Small delay to allow the user to finish typing on mobile
                        setTimeout(() => {
                            saveEditableDetail();
                            saveScheduled = false;
                        }, 100);
                    };
                    
                    inputElement.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            // Save immediately on Enter key
                            saveEditableDetail();
                        }
                    });
                    // Use blur event for saving when user leaves the field
                    // Small delay helps prevent premature saves on mobile keyboards
                    inputElement.addEventListener('blur', scheduleSave);
                }
                displaySpan.style.display = 'none';
            };
            displaySpan.addEventListener('click', newClickHandler);
            item._displaySpanClickHandler = newClickHandler;
        }
        function saveEditableDetail() {
            if (!currentEditableDetailElement) return;
            const { item, metricId, section, metricConfig, displaySpan, inputElement, otherInput } = currentEditableDetailElement;
            let newValue;
            if (metricConfig.type === 'select') {
                if (inputElement.value === 'other_input_field' && otherInput) {
                    newValue = otherInput.value.trim();
                } else {
                    newValue = inputElement.value;
                }
                if (otherInput) {
                    otherInput.remove();
                }
            } else {
                newValue = inputElement.value;
            }
            if (metricConfig.type === 'number') {
                newValue = parseFloat(newValue);
            }
            const oldValue = displaySpan.textContent === '--' ? '' : displaySpan.textContent;
            if (newValue !== oldValue && (metricConfig.type === 'number' ? !isNaN(newValue) : newValue !== "")) {
                updateProjectDetailValue(section, metricId, newValue);
                // Update display value without full card refresh
                const latestValue = getLatestProjectDetailValue(section, metricId);
                displaySpan.textContent = latestValue;
            }
            if (inputElement) {
                inputElement.remove();
            }
            displaySpan.style.display = 'block';
            currentEditableDetailElement = null;
            // Only update dashboard if this is the current stage, but don't refresh the entire card
            if (section === currentStageId) {
                updateDashboardForCurrentStage();
            }
            renderPreviousStageOverview();
        }
        
        function getLatestProjectDetailValue(section, metricId) {
            let entries;
            if (section === 'wineDetails') {
                const predefinedMetricConfig = stagesConfig.wineDetails.metrics[metricId];
                if (predefinedMetricConfig) {
                    entries = projects[currentProjectId].wineDetails[metricId];
                } else {
                    const customProp = projects[currentProjectId].wineDetails.customProperties.find(prop => prop.id === metricId);
                    entries = customProp ? customProp.history : null;
                }
            } else {
                entries = projects[currentProjectId].stages[section][metricId];
            }
            if (entries && entries.length > 0) {
                return entries[entries.length - 1].value;
            }
            return '--';
        }
        function updateProjectDetailValue(section, metricId, newValue) {
            if (!ensureEditPermission()) {
                return;
            }
            let metricDataArray;
            if (section === 'wineDetails') {
                const predefinedMetricConfig = stagesConfig.wineDetails.metrics[metricId];
                if (predefinedMetricConfig) {
                    metricDataArray = projects[currentProjectId].wineDetails[metricId];
                } else {
                    const customProp = projects[currentProjectId].wineDetails.customProperties.find(prop => prop.id === metricId);
                    if (customProp) {
                        metricDataArray = customProp.history;
                    } else {
                        console.error("Attempted to update non-existent custom property or metric:", metricId);
                        return;
                    }
                }
            } else {
                metricDataArray = projects[currentProjectId].stages[section][metricId];
            }
            const timestamp = new Date().toLocaleString('he-IL', {
                year: 'numeric', month: 'numeric', day: 'numeric',
                hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
            });
            if (!metricDataArray) {
                console.error("Metric data array not found, initializing:", section, metricId);
                if (section === 'wineDetails') {
                    if (stagesConfig.wineDetails.metrics[metricId]) {
                        projects[currentProjectId].wineDetails[metricId] = [];
                    } else {
                        return;
                    }
                } else {
                    if (!projects[currentProjectId].stages[section]) projects[currentProjectId].stages[section] = {};
                    projects[currentProjectId].stages[section][metricId] = [];
                }
                metricDataArray = (section === 'wineDetails' ? projects[currentProjectId].wineDetails[metricId] : projects[currentProjectId].stages[section][metricId]);
            }
            if (metricDataArray.length > 0) {
                metricDataArray[metricDataArray.length - 1].value = newValue;
                metricDataArray[metricDataArray.length - 1].timestamp = timestamp;
            } else {
                metricDataArray.push({ value: newValue, timestamp: timestamp });
            }
            saveAllProjects();
            updateProjectDetailsCard();
            if (section === currentStageId) {
                updateDashboardForCurrentStage();
            }
            renderPreviousStageOverview();
        }
        function showDatePicker(initialDate, callback) {
            datePickerCallback = callback;
            datePickerModal.style.display = 'flex';
            let initialMonth, initialYear;
            if (initialDate && initialDate.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
                const parts = initialDate.split('/');
                initialMonth = parseInt(parts[1], 10) - 1;
                initialYear = parseInt(parts[2], 10);
            } else {
                const today = new Date();
                initialMonth = today.getMonth();
                initialYear = today.getFullYear();
            }
            datePickerCurrentMonth = initialMonth;
            datePickerCurrentYear = initialYear;
            renderCalendar(datePickerCurrentMonth, datePickerCurrentYear);
            document.getElementById('prevMonthBtn').onclick = () => {
                datePickerCurrentMonth--;
                if (datePickerCurrentMonth < 0) {
                    datePickerCurrentMonth = 11;
                    datePickerCurrentYear--;
                }
                renderCalendar(datePickerCurrentMonth, datePickerCurrentYear);
            };
            document.getElementById('nextMonthBtn').onclick = () => {
                datePickerCurrentMonth++;
                if (datePickerCurrentMonth > 11) {
                    datePickerCurrentMonth = 0;
                    datePickerCurrentYear++;
                }
                renderCalendar(datePickerCurrentMonth, datePickerCurrentYear);
            };
        }
        function closeDatePickerModal() {
            datePickerModal.style.display = 'none';
            if (currentEditableDetailElement) {
                currentEditableDetailElement.displaySpan.style.display = 'block';
                if (currentEditableDetailElement.inputElement) {
                    currentEditableDetailElement.inputElement.remove();
                }
                if (currentEditableDetailElement.otherInput) {
                    currentEditableDetailElement.otherInput.remove();
                }
            }
            currentEditableDetailElement = null;
            datePickerCallback = null;
        }
        function renderCalendar(month, year) {
            datePickerGrid.innerHTML = `
                <div class="date-picker-day header">א</div>
                <div class="date-picker-day header">ב</div>
                <div class="date-picker-day header">ג</div>
                <div class="date-picker-day header">ד</div>
                <div class="date-picker-day header">ה</div>
                <div class="date-picker-day header">ו</div>
                <div class="date-picker-day header">ש</div>
            `;
            currentMonthYearDisplay.textContent = new Date(year, month).toLocaleString('he-IL', { month: 'long', year: 'numeric' });
            const firstDayOfMonth = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const startDayIndex = firstDayOfMonth;
            for (let i = 0; i < startDayIndex; i++) {
                const dayDiv = document.createElement('div');
                dayDiv.classList.add('date-picker-day', 'empty');
                datePickerGrid.appendChild(dayDiv);
            }
            for (let day = 1; day <= daysInMonth; day++) {
                const dayDiv = document.createElement('div');
                dayDiv.classList.add('date-picker-day', 'current-month');
                dayDiv.textContent = day;
                dayDiv.onclick = () => selectDate(day, month, year);
                datePickerGrid.appendChild(dayDiv);
            }
        }
        function selectDate(day, month, year) {
            const selectedDate = `${String(day).padStart(2, '0')}/${String(month + 1).padStart(2, '0')}/${year}`;
            if (datePickerCallback) {
                datePickerCallback(selectedDate);
            }
            closeDatePickerModal();
        }
        function openInstructionsModal() {
            closeSidebar();
            document.querySelector('.container').style.display = 'none';
            document.querySelector('.top-section-wrapper').style.display = 'none';
            fixedDashboardSection.style.display = 'none';
            instructionsModal.style.display = 'flex';
        }
        function closeInstructionsModal() {
            instructionsModal.style.display = 'none';
            showMainContent();
        }
        function openTimelineModal() {
            closeSidebar();
            document.querySelector('.container').style.display = 'none';
            document.querySelector('.top-section-wrapper').style.display = 'none';
            fixedDashboardSection.style.display = 'none';
            timelineModal.style.display = 'flex';
            renderTimeline();
        }
        function closeTimelineModal() {
            timelineModal.style.display = 'none';
            showMainContent();
        }
        function renderTimeline() {
            timelineContainer.innerHTML = '';
            let allEntries = [];
            const currentProject = projects[currentProjectId];
            for (const metricId in stagesConfig.wineDetails.metrics) {
                const metricConfig = stagesConfig.wineDetails.metrics[metricId];
                const entries = currentProject.wineDetails[metricId];
                if (entries && entries.length > 0) {
                    entries.forEach(entry => {
                        allEntries.push({
                            sectionName: stagesConfig.wineDetails.longName,
                            metricName: metricConfig.name,
                            value: entry.value,
                            timestamp: entry.timestamp,
                            rawTimestamp: new Date(entry.timestamp.replace(/(\d{2})\/(\d{2})\/(\d{4}), (\d{2}):(\d{2}):(\d{2})/, '$3-$2-$1T$4:$5:$6')),
                            color: '#8B0000'
                        });
                    });
                }
            }
            if (currentProject.wineDetails.customProperties) {
                currentProject.wineDetails.customProperties.forEach(prop => {
                    if (prop.history && prop.history.length > 0) {
                        prop.history.forEach(entry => {
                            allEntries.push({
                                sectionName: stagesConfig.wineDetails.longName,
                                metricName: prop.name,
                                value: entry.value,
                                timestamp: entry.timestamp,
                                rawTimestamp: new Date(entry.timestamp.replace(/(\d{2})\/(\d{2})\/(\d{4}), (\d{2}):(\d{2}):(\d{2})/, '$3-$2-$1T$4:$5:$6')),
                                color: '#A52A2A'
                            });
                        });
                    }
                });
            }
            for (const stageId in currentProject.stages) {
                const stageConfig = stagesConfig[stageId];
                if (!stageConfig || stageId === 'wineDetails') continue;
                const stageColor = stageConfig.emoji === '🟢' ? '#228B22' : stageConfig.emoji === '🍇' ? '#8B4513' : stageConfig.emoji === '🍷' ? '#B22222' : stageConfig.emoji === '🔁' ? '#FF6347' : stageConfig.emoji === '🛢' ? '#696969' : stageConfig.emoji === '🧪' ? '#4169E1' : '#8B0000';
                for (const metricId in stageConfig.metrics) {
                    const metricConfig = stageConfig.metrics[metricId];
                    const entries = currentProject.stages[stageId][metricId];
                    if (entries && entries.length > 0) {
                        entries.forEach(entry => {
                            allEntries.push({
                                sectionName: stageConfig.longName,
                                metricName: metricConfig.name,
                                value: entry.value,
                                timestamp: entry.timestamp,
                                rawTimestamp: new Date(entry.timestamp.replace(/(\d{2})\/(\d{2})\/(\d{4}), (\d{2}):(\d{2}):(\d{2})/, '$3-$2-$1T$4:$5:$6')),
                                color: stageColor
                            });
                        });
                    }
                }
            }
            allEntries.sort((a, b) => a.rawTimestamp - b.rawTimestamp);
            if (allEntries.length === 0) {
                timelineContainer.innerHTML = '<p style="text-align: center; color: var(--light-text-color);">אין נתונים זמינים עבור ציר הזמן בפרויקט זה.</p>';
                return;
            }
            allEntries.forEach((entry, index) => {
                const eventDiv = document.createElement('div');
                eventDiv.className = 'timeline-event';
                eventDiv.style.animationDelay = `${index * 0.1}s`;
                eventDiv.innerHTML = `
                    <div class="timeline-event-content" style="border-left: 5px solid ${entry.color};">
                        <h4 style="color: ${entry.color};">${entry.metricName} (${entry.sectionName})</h4>
                        <p>ערך: <span class="event-value">${entry.value}</span></p>
                        <span class="event-timestamp">${entry.timestamp}</span>
                    </div>
                `;
                timelineContainer.appendChild(eventDiv);
            });
        }
        function downloadTimelinePDF() {
            const entries = Array.from(timelineContainer.querySelectorAll('.timeline-event')).map((event, index) => {
                const title = event.querySelector('h4').textContent;
                const value = event.querySelector('.event-value').textContent;
                const timestamp = event.querySelector('.event-timestamp').textContent;
                return `${index + 1}. ${title}\nערך: ${value}\nתאריך: ${timestamp}`;
            });
            const docDefinition = {
                content: [
                    { text: 'ציר זמן - כל המדידות', style: 'header' },
                    { text: entries.join('\n\n'), style: 'text' }
                ],
                styles: {
                    header: { fontSize: 18, bold: true, alignment: 'right' },
                    text: { fontSize: 12, alignment: 'right' }
                }
            };
            pdfMake.createPdf(docDefinition).download('timeline.pdf');
        }
        function downloadCurrentProjectFinancePDF() {
            const docDefinition = {
                content: [
                    { text: 'דוח כספי - פרויקט נוכחי', style: 'header' },
                    { text: `סה"כ הכנסות: ${currentProjectTotalIncomeDisplay.textContent} ₪`, style: 'text' },
                    { text: `סה"כ הוצאות: ${currentProjectTotalExpenseDisplay.textContent} ₪`, style: 'text' },
                    { text: `יתרה נוכחית: ${currentProjectTotalBalanceDisplay.textContent} ₪`, style: 'text' },
                    { text: 'תנועות:', style: 'subheader' },
                    {
                        table: {
                            headerRows: 1,
                            widths: ['*', '*', '*', '*'],
                            body: [
                                ['תאריך', 'סוג', 'סכום', 'הערות'],
                                ...Array.from(currentProjectFinanceReportTableBody.querySelectorAll('tr')).map(row => {
                                    const cells = row.querySelectorAll('td');
                                    return [cells[0].textContent, cells[1].textContent, cells[2].textContent, cells[3].textContent];
                                })
                            ]
                        }
                    }
                ],
                styles: {
                    header: { fontSize: 18, bold: true, alignment: 'right' },
                    subheader: { fontSize: 14, bold: true, alignment: 'right' },
                    text: { fontSize: 12, alignment: 'right' }
                }
            };
            pdfMake.createPdf(docDefinition).download('current_project_finance_report.pdf');
        }
        function downloadGlobalFinancePDF() {
            const docDefinition = {
                content: [
                    { text: 'דוח כספי כולל (כל הפרויקטים)', style: 'header' },
                    { text: `סה"כ הכנסות: ${globalTotalIncomeDisplay.textContent} ₪`, style: 'text' },
                    { text: `סה"כ הוצאות: ${globalTotalExpenseDisplay.textContent} ₪`, style: 'text' },
                    { text: `יתרה כוללת: ${globalTotalBalanceDisplay.textContent} ₪`, style: 'text' },
                    { text: 'פרויקטים:', style: 'subheader' },
                    ...Array.from(globalFinanceProjectsDetails.querySelectorAll('.global-finance-project-section')).map(section => {
                        const title = section.querySelector('h4').textContent;
                        const ps = Array.from(section.querySelectorAll('p')).map(p => p.textContent);
                        return { text: `${title}\n${ps.join('\n')}`, style: 'text' };
                    })
                ],
                styles: {
                    header: { fontSize: 18, bold: true, alignment: 'right' },
                    subheader: { fontSize: 14, bold: true, alignment: 'right' },
                    text: { fontSize: 12, alignment: 'right' }
                }
            };
            pdfMake.createPdf(docDefinition).download('global_finance_report.pdf');
        }
        function downloadYearlyFinancePDF() {
            const docDefinition = {
                content: [
                    { text: `דוח כספי לפי שנה - ${yearSelect.value}`, style: 'header' },
                    { text: `סה"כ הכנסות: ${yearlyTotalIncomeDisplay.textContent} ₪`, style: 'text' },
                    { text: `סה"כ הוצאות: ${yearlyTotalExpenseDisplay.textContent} ₪`, style: 'text' },
                    { text: `יתרה נוכחית: ${yearlyTotalBalanceDisplay.textContent} ₪`, style: 'text' },
                    { text: 'פרויקטים:', style: 'subheader' },
                    ...Array.from(yearlyFinanceProjectsDetails.querySelectorAll('.finance-yearly-project-section')).map(section => {
                        const title = section.querySelector('h4').textContent;
                        const ps = Array.from(section.querySelectorAll('p')).map(p => p.textContent);
                        return { text: `${title}\n${ps.join('\n')}`, style: 'text' };
                    })
                ],
                styles: {
                    header: { fontSize: 18, bold: true, alignment: 'right' },
                    subheader: { fontSize: 14, bold: true, alignment: 'right' },
                    text: { fontSize: 12, alignment: 'right' }
                }
            };
            pdfMake.createPdf(docDefinition).download(`yearly_finance_report_${yearSelect.value}.pdf`);
        }
        window.onclick = function(event) {
            if (event.target === historyModal) {
                closeHistoryModal();
            }
            if (event.target === projectManagementModal) {
                closeProjectManagementModal();
            }
            if (event.target === financeModal) {
                closeFinanceModal();
            }
            if (event.target === currentProjectFinanceReportModal) {
                closeCurrentProjectFinanceReportModal();
            }
            if (event.target === globalFinanceReportModal) {
                closeGlobalFinanceReportModal();
            }
            if (event.target === financeYearlyModal) {
                closeFinanceYearlyModal();
            }
            if (event.target === inboxModal) {
                closeInboxModal();
            }
            if (event.target === remindersModal) {
                closeRemindersModal();
            }
            if (event.target === instructionsModal) {
                closeInstructionsModal();
            }
            if (event.target === timelineModal) {
                closeTimelineModal();
            }
            if (event.target === datePickerModal && !event.target.closest('.date-picker-modal-content')) {
                closeDatePickerModal();
            }
            if (event.target === projectSelectionModal) {
                closeProjectSelectionModal();
            }
            if (event.target === newProjectModal) {
                closeNewProjectModal();
            }
            if (event.target === customPropertyModal) {
                closeCustomPropertyModal();
            }
            if (event.target === financeEditModal) {
                closeFinanceEditModal();
            }
            if (event.target === accessControlModal) {
                closeAccessControlModal();
            }
            const manageEmailsModal = document.getElementById('manageEmailsModal');
            if (event.target === manageEmailsModal) {
                closeManageEmailsModal();
            }
            const confirmationModal = document.getElementById('confirmationModal');
            if (event.target === confirmationModal) {
                // Close confirmation modal by clicking "No"
                const noBtn = document.getElementById('confirmNoBtn');
                if (noBtn) noBtn.click();
            }
            if (event.target === sidebarOverlay) {
                closeSidebar();
            }
        }
        function openAddMetricModal() {
            document.getElementById('addMetricModal').style.display = 'flex';
        }
        function closeAddMetricModal() {
            document.getElementById('addMetricModal').style.display = 'none';
        }
        function addNewMetric() {
            if (!ensureEditPermission()) {
                return;
            }
            const name = document.getElementById('addMetricName').value.trim();
            if (name) {
                // Generate unique metric ID
                const metricId = `customMetric_${Date.now()}`;
                
                // Add to stagesConfig customMetrics
                if (!stagesConfig[currentStageId].customMetrics) {
                    stagesConfig[currentStageId].customMetrics = {};
                }
                stagesConfig[currentStageId].customMetrics[metricId] = {
                    name: name,
                    type: 'text',
                    placeholder: 'הכנס ערך'
                };
                
                // Initialize data array in project
                if (!projects[currentProjectId].stages[currentStageId]) {
                    projects[currentProjectId].stages[currentStageId] = {};
                }
                projects[currentProjectId].stages[currentStageId][metricId] = [];
                
                // Save to localStorage
                saveAllProjects();
                
                // Clear input and close modal
                document.getElementById('addMetricName').value = '';
                closeAddMetricModal();
                
                // Re-render the current stage to show the new metric
                loadCurrentStageContent();
            } else {
                alert('אנא הזן שם למדד.');
            }
        }
        function deleteCustomMetric(stageId, metricId, skipConfirm = false) {
            if (!ensureEditPermission()) {
                return;
            }
            if (!stageId || !metricId) return;
            if (!stagesConfig[stageId] || !stagesConfig[stageId].customMetrics || !stagesConfig[stageId].customMetrics[metricId]) return;
            if (!skipConfirm && !confirm('למחוק את המדד המותאם? פעולה זו תמחק גם את הנתונים שלו.')) return;
            delete stagesConfig[stageId].customMetrics[metricId];
            Object.keys(projects).forEach(pid => {
                if (projects[pid]?.stages?.[stageId]) {
                    delete projects[pid].stages[stageId][metricId];
                }
            });
            saveAllProjects();
            if (stageId === currentStageId) {
                loadCurrentStageContent();
            } else {
                updateDashboardForCurrentStage();
            }
        }
        function getCurrentAppState() {
            return {
                projects: projects,
                currentProjectId: currentProjectId,
                currentStageId: currentStageId,
                stagesConfig: stagesConfig, // Save custom metrics in stagesConfig
                darkMode: document.body.classList.contains('dark-mode'),
                savedAt: new Date().toISOString()
            };
        }
        
        // IndexedDB helper functions for reminders to avoid localStorage QuotaExceededError
        const REMINDERS_DB_NAME = "reminders-db";
        const REMINDERS_STORE_NAME = "reminders";
        
        function openRemindersDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(REMINDERS_DB_NAME, 1);
                req.onupgradeneeded = () => {
                    const db = req.result;
                    if (!db.objectStoreNames.contains(REMINDERS_STORE_NAME)) {
                        db.createObjectStore(REMINDERS_STORE_NAME, { keyPath: "id" });
                    }
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }
        
        async function saveReminderToIndexedDB(reminder) {
            try {
                const db = await openRemindersDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(REMINDERS_STORE_NAME, "readwrite");
                    tx.objectStore(REMINDERS_STORE_NAME).put(reminder);
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
            } catch (error) {
                console.error('IndexedDB save error:', error);
                throw error;
            }
        }
        
        async function getAllRemindersFromIndexedDB() {
            try {
                const db = await openRemindersDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(REMINDERS_STORE_NAME, "readonly");
                    const req = tx.objectStore(REMINDERS_STORE_NAME).getAll();
                    req.onsuccess = () => resolve(req.result || []);
                    req.onerror = () => reject(req.error);
                });
            } catch (error) {
                console.error('IndexedDB read error:', error);
                return [];
            }
        }
        
        async function deleteReminderFromIndexedDB(id) {
            try {
                const db = await openRemindersDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(REMINDERS_STORE_NAME, "readwrite");
                    tx.objectStore(REMINDERS_STORE_NAME).delete(id);
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
            } catch (error) {
                console.error('IndexedDB delete error:', error);
                throw error;
            }
        }
        
        // Helper function to handle localStorage quota exceeded errors
        // Helper function to handle localStorage errors
        function handleLocalStorageError(err) {
            console.error('Error saving to localStorage:', err);
            if (err.name === 'QuotaExceededError') {
                alert('שגיאה: אחסון המכשיר מלא. אנא פנה מקום על ידי מחיקת קבצים או נתונים מהדפדפן ונסה שוב.');
            } else if (err.name === 'SecurityError') {
                // Private/incognito mode or security restrictions
                alert('שגיאה: לא ניתן לשמור נתונים במצב גלישה פרטית. אנא פתח את האתר במצב רגיל או התחבר כדי לשמור בענן.');
            } else {
                // Generic fallback for other errors
                console.error('Unexpected localStorage error:', err.name, err.message);
                // Note: Don't show alert for unexpected errors to avoid annoying users
            }
        }
        
        // Helper function to safely load and render from localStorage
        function loadAndRenderFromLocalStorage() {
            const localProjects = localStorage.getItem('projects');
            if (localProjects) {
                try {
                    projects = JSON.parse(localProjects);
                    if (typeof renderAllMainContent === 'function') {
                        renderAllMainContent();
                    }
                } catch (parseErr) {
                    console.error('Error parsing localStorage projects:', parseErr);
                }
            }
        }
        
        function applyStateToUI(state) {
            if (!state) return;
            if (state.projects) {
                projects = state.projects;
            }
            if (state.stagesConfig) {
                // Merge stagesConfig to preserve custom metrics
                Object.keys(state.stagesConfig).forEach(stageId => {
                    if (state.stagesConfig[stageId].customMetrics) {
                        if (!stagesConfig[stageId]) {
                            stagesConfig[stageId] = state.stagesConfig[stageId];
                        } else {
                            stagesConfig[stageId].customMetrics = state.stagesConfig[stageId].customMetrics;
                        }
                    }
                });
            }
            if (state.currentProjectId && projects[state.currentProjectId]) {
                currentProjectId = state.currentProjectId;
                localStorage.setItem('currentProjectId', currentProjectId);
            }
            if (state.currentStageId && stagesConfig[state.currentStageId]) {
                currentStageId = state.currentStageId;
                localStorage.setItem('currentStageId', currentStageId);
            }
            if (state.darkMode) {
                document.body.classList.add('dark-mode');
                localStorage.setItem('darkMode', 'true');
            } else {
                document.body.classList.remove('dark-mode');
                localStorage.setItem('darkMode', 'false');
            }
            if (typeof renderAllMainContent === 'function') {
                renderAllMainContent();
            } else if (typeof updateProjectDisplay === 'function') {
                updateProjectDisplay();
            }
        }
        function loadStateFromFirebase() { 
            // Firebase removed - localStorage only
            loadAndRenderFromLocalStorage();
        }
        function loadSharedStateByOwner(ownerUid) {
            // Firebase sharing removed - localStorage only
            console.log('Shared access not available without Firebase');
        }
        function checkUserAccess() {
            // Firebase access management removed - use local AccessManagement instead
            return;
        }
        
        function handleInviteFromUrl() {
            // Firebase invites removed - localStorage only
            return;
        }
        
        // Firebase realtime sync functions removed
        function setupInboxRealtimeSync(user) {
            // Firebase realtime sync removed - localStorage only
            return;
        }
        
        function setupRemindersRealtimeSync(user) {
            // Firebase realtime sync removed - localStorage only
            return;
        }
        
        function setupRealtimeSync(user) {
            // Firebase realtime sync removed - localStorage only
            return;
        }
        
        function showSyncNotification() {
            // Create a temporary notification element
            const notification = document.createElement('div');
            notification.style.position = 'fixed';
            notification.style.top = '80px';
            notification.style.right = '20px';
            notification.style.background = 'linear-gradient(135deg, #4CAF50, #66BB6A)';
            notification.style.color = 'white';
            notification.style.padding = '10px 20px';
            notification.style.borderRadius = '8px';
            notification.style.zIndex = '9999';
            notification.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
            notification.style.fontSize = '14px';
            notification.style.fontWeight = 'bold';
            notification.textContent = '✓ הנתונים עודכנו';
            notification.style.animation = 'slideInRight 0.3s ease-out';
            notification.className = 'sync-notification';
            
            document.body.appendChild(notification);
            
            // Remove after 2 seconds
            setTimeout(() => {
                notification.style.animation = 'fadeOut 0.3s ease-out';
                setTimeout(() => {
                    // Check if element still exists before removing
                    if (notification.parentNode) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, 2000);
        }
        
        async function saveStateToFirebase() {
            // Save to localStorage only (Firebase removed)
            try {
                localStorage.setItem('projects', JSON.stringify(projects));
                console.log('State saved to localStorage');
            } catch (err) {
                console.error('Error saving to localStorage:', err);
            }
        }
        function openLoginModal() {
            const modal = document.getElementById('loginModal');
            if (modal) {
                modal.style.display = 'flex';
            }
        }
        function closeLoginModal() {
            const modal = document.getElementById('loginModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        function skipLogin() {
            closeLoginModal();
        }
        function isMobileDevice() {
            // Check for touch support
            const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            // Check screen size
            const isSmallScreen = window.innerWidth <= 768;
            // Check user agent as fallback
            const mobileUA = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Consider it mobile if it has touch AND small screen, OR matches mobile UA
            return (hasTouch && isSmallScreen) || mobileUA;
        }
        
        function loginWithGoogle() {
            const googleProvider = {}  // Google auth removed;
            
            // Device language removed
            
            if (isMobileDevice()) {
                // On mobile, use redirect without any prompt parameter
                // This allows the most seamless experience - the system will automatically
                // use the primary Google account on the device if only one is logged in
                // or show a minimal selection if multiple accounts are available
                // Redirect sign-in removed
            } else {
                // On desktop, always prompt for account selection
                googleProvider.setCustomParameters({
                    prompt: 'select_account'
                });
                // On desktop, try popup first with fallback to redirect
                Promise.reject(new Error("Google sign-in removed"))
                    .then((result) => {
                        console.log('User signed in with Google:', result.user);
                        closeLoginModal();
                    })
                    .catch((error) => {
                        console.error('Popup failed, trying redirect:', error);
                        // Redirect sign-in removed
                    });
            }
        }
        
        /**
         * Google Identity Services (GIS) callback handler
         * This function is called when user selects an account from the GIS account picker
         * The credential response contains the ID token which can be verified server-side
         * 
         * @param {Object} response - The credential response from Google
         * @param {string} response.credential - The ID token (JWT) from Google
         */
        function handleGoogleSignIn(response) {
            console.log('Google Sign-In via GIS - ID Token received');
            
            // The ID token is in response.credential
            const idToken = response.credential;
            
            // In a production environment, you would send this ID token to your backend
            // for verification and authentication. Example:
            // 
            // fetch('/api/auth/google', {
            //     method: 'POST',
            //     headers: {
            //         'Content-Type': 'application/json',
            //     },
            //     body: JSON.stringify({ idToken: idToken })
            // })
            // .then(res => res.json())
            // .then(data => {
            //     // Handle successful authentication
            //     console.log('User authenticated:', data);
            // })
            // .catch(err => {
            //     console.error('Authentication error:', err);
            // });
            
            // Cloud sync disabled
            // This demonstrates the integration while we're in client-side only mode
            // The second parameter (accessToken) is optional and can be null for ID token only auth
            // Firebase credential removed
            
            auth.signInWithCredential(credential)
                .then((result) => {
                    console.log('User signed in with GIS credential:', result.user);
                    closeLoginModal();
                })
                .catch((error) => {
                    console.error('Error signing in with GIS credential:', error);
                    alert('שגיאה בהתחברות: ' + error.message);
                });
        }
        
        async function checkAndPromptForSitePassword(user) {
            // Check if user has suppressed the prompt
            if (localStorage.getItem('suppressSitePasswordPrompt') === '1') {
                return;
            }
            
            try {
                // Check if user has a site password set in Firestore
                const userDoc = await db.collection('userSitePasswords').doc(user.uid).get();
                
                if (!userDoc.exists) {
                    // User doesn't have a site password, prompt them to set one
                    openPasswordSetupModal();
                }
            } catch (error) {
                console.error('Error checking site password:', error);
            }
        }
        
        function openPasswordSetupModal() {
            const modal = document.getElementById('passwordSetupModal');
            if (modal) {
                modal.style.display = 'flex';
            }
        }
        
        function closePasswordSetupModal() {
            const modal = document.getElementById('passwordSetupModal');
            if (modal) {
                modal.style.display = 'none';
                // Clear inputs
                document.getElementById('newSitePassword').value = '';
                document.getElementById('confirmSitePassword').value = '';
            }
        }
        
        function skipPasswordSetup() {
            localStorage.setItem('suppressSitePasswordPrompt', '1');
            closePasswordSetupModal();
        }
        
        async function saveSitePassword() {
            const user = auth?.currentUser;
            if (!user || !user.email) {
                alert('אנא התחבר קודם.');
                return;
            }
            
            const newPasswordEl = document.getElementById('newSitePassword');
            const confirmPasswordEl = document.getElementById('confirmSitePassword');
            
            if (!newPasswordEl || !confirmPasswordEl) {
                console.error('Password input elements not found');
                alert('שגיאה: לא נמצאו שדות הסיסמה. נסה לרענן את הדף.');
                return;
            }
            
            const newPassword = newPasswordEl.value;
            const confirmPassword = confirmPasswordEl.value;
            
            if (!newPassword || !confirmPassword) {
                alert('אנא מלא את כל השדות.');
                return;
            }
            
            if (newPassword.length < 6) {
                alert('הסיסמה חייבת להיות לפחות 6 תווים.');
                return;
            }
            
            if (newPassword !== confirmPassword) {
                alert('הסיסמאות אינן תואמות.');
                return;
            }
            
            try {
                // Link email/password provider to the existing Google account
                // Firebase credential removed
                Promise.reject(new Error("Email linking removed"));
                
                // Save a marker in Firestore that this user has set up site password
                await db.collection('userSitePasswords').doc(user.uid).set({
                    email: user.email,
                    hasPassword: true,
                    createdAt: Date.now(),
                    updatedAt: Date.now()
                });
                
                alert('הסיסמה נשמרה בהצלחה! עכשיו תוכל להתחבר עם ' + user.email + ' והסיסמה שהגדרת ממכשירים אחרים.');
                closePasswordSetupModal();
            } catch (error) {
                console.error('Error saving site password:', error);
                if (error.code === 'auth/provider-already-linked') {
                    // Password provider already linked, try updating instead
                    try {
                        // User already has a password, need to update it
                        // This requires re-authentication, so we'll inform the user
                        alert('כדי לעדכן את הסיסמה, עליך להתחבר מחדש תחילה. אנא צא וחזור לאתר, ולאחר מכן נסה שוב.');
                        closePasswordSetupModal();
                    } catch (updateError) {
                        console.error('Error updating password:', updateError);
                        alert('שגיאה בעדכון הסיסמה: ' + updateError.message);
                    }
                } else if (error.code === 'auth/email-already-in-use') {
                    alert('כבר קיים חשבון עם אימייל זה. נסה להתחבר עם הסיסמה.');
                    closePasswordSetupModal();
                } else if (error.code === 'auth/requires-recent-login') {
                    alert('נדרשת התחברות מחודשת. אנא צא ממערכת והתחבר שוב, ולאחר מכן נסה להגדיר סיסמה.');
                    closePasswordSetupModal();
                } else {
                    alert('שגיאה בשמירת הסיסמה: ' + error.message);
                }
            }
        }
        
        /**
         * Toggle between registration and login forms
         */
        function toggleLoginMode() {
            const registrationForm = document.getElementById('registrationForm');
            const loginForm = document.getElementById('loginForm');
            
            if (registrationForm && loginForm) {
                if (registrationForm.style.display === 'none') {
                    // Switch to registration mode
                    registrationForm.style.display = 'flex';
                    loginForm.style.display = 'none';
                } else {
                    // Switch to login mode
                    registrationForm.style.display = 'none';
                    loginForm.style.display = 'flex';
                }
            }
        }
        
        /**
         * Save user data to Firestore
         */
        async function saveUserToFirestore(user, email) {
            try {
                await waitForFirebase();
                
                console.log('Attempting to save user to Firestore:', user.uid);
                
                // Check if user already exists in Firestore
                const userDocRef = window.firestoreDoc(window.firebaseDb, 'users', user.uid);
                const userDoc = await window.firestoreGetDoc(userDocRef);
                
                if (!userDoc.exists()) {
                    // Create user document
                    const userEmail = email || user.email;
                    const userData = {
                        email: userEmail,
                        createdAt: window.firestoreServerTimestamp(),
                        displayName: user.displayName || (userEmail ? userEmail.split('@')[0] : 'User'),
                        uid: user.uid
                    };
                    
                    console.log('Saving new user data:', userData);
                    await window.firestoreSetDoc(userDocRef, userData);
                    console.log('✓ User data saved to Firestore successfully');
                } else {
                    console.log('User already exists in Firestore, skipping creation');
                }
            } catch (error) {
                console.error('❌ Error saving user to Firestore:', error);
                console.error('Error code:', error.code);
                console.error('Error message:', error.message);
                
                // More specific error messages
                if (error.code === 'permission-denied') {
                    console.error('Permission denied - check Firestore security rules');
                    showNotification('שגיאת הרשאה בשמירת נתונים. אנא פנה למנהל המערכת', 'error');
                } else if (error.code === 'unavailable') {
                    console.error('Firestore unavailable - check network connection');
                    showNotification('שירות הענן אינו זמין כרגע. נסה שוב מאוחר יותר', 'error');
                }
                
                throw error;
            }
        }
        
        /**
         * Check if the current domain can use Firebase redirect handler
         * 
         * Firebase's signInWithRedirect requires a special handler at /__/auth/handler
         * which is only available on Firebase Hosting domains. GitHub Pages doesn't
         * provide this endpoint, so redirect authentication will fail with 404.
         * 
         * This function checks if the current hostname is:
         * 1. The exact authDomain from Firebase config (e.g., wine-cd8b9.firebaseapp.com)
         * 2. Any subdomain of .firebaseapp.com
         * 3. Any subdomain of .web.app (newer Firebase Hosting domains)
         * 
         * Returns true only if hosted on Firebase domains where redirect will work.
         * Returns false on GitHub Pages (*.github.io) and other non-Firebase domains.
         * 
         * @returns {boolean} True if redirect authentication can be used
         */
        function canUseRedirectHandler() {
            const host = window.location.hostname || '';
            const authDomain = (window.firebaseApp && window.firebaseApp.options && window.firebaseApp.options.authDomain) || '';
            return host === authDomain || host.endsWith('.firebaseapp.com') || host.endsWith('.web.app');
        }
        
        /**
         * Manually trigger redirect login (only works on Firebase hosting domains)
         * 
         * This function provides a manual redirect option for users whose browsers
         * block popups. It should ONLY be called when canUseRedirectHandler() returns true.
         * 
         * On GitHub Pages, this will fail because /__/auth/handler doesn't exist.
         * The UI hides the redirect button on non-Firebase domains to prevent this.
         * 
         * Flow:
         * 1. Check if redirect is available on current domain
         * 2. Initialize Google provider
         * 3. Call signInWithRedirect (page will reload and redirect to Google)
         * 4. After redirect back, handleRedirectResult() will complete the login
         * 
         * @see canUseRedirectHandler
         * @see handleRedirectResult
         */
        async function startRedirectLogin() {
            if (!canUseRedirectHandler()) {
                showNotification('הפניה לא זמינה מדומיין זה. אנא אפשר חלונות קופצים בדפדפן.', 'error');
                return;
            }
            
            try {
                showLoading('מפנה להתחברות...');
                await waitForFirebase();
                
                const provider = new window.firebaseGoogleAuthProvider();
                
                console.log('Starting redirect login flow...');
                await window.firebaseSignInWithRedirect(auth, provider);
                // Note: page will reload after redirect, so hideLoading won't execute
            } catch (error) {
                hideLoading();
                console.error('Redirect login error:', error);
                showNotification('שגיאה בהפניה להתחברות: ' + (error.message || 'שגיאה לא ידועה'), 'error');
            }
        }
        
        /**
         * Sign in with Google using popup authentication
         * 
         * AUTHENTICATION STRATEGY FOR GITHUB PAGES:
         * =========================================
         * 
         * This function implements a popup-first approach with intelligent fallback
         * handling that works correctly on both Firebase Hosting and GitHub Pages.
         * 
         * Flow:
         * 1. Always attempt signInWithPopup() first (works on all domains)
         * 2. If popup succeeds: Save user to Firestore and complete login
         * 3. If popup fails due to blocking:
         *    a. On Firebase domains: Show manual redirect button as alternative
         *    b. On GitHub Pages: Show message to enable popups (no redirect option)
         * 4. For other errors: Show appropriate error message
         * 
         * Why this approach:
         * - Popups work on all domains (GitHub Pages, Firebase, localhost)
         * - Redirect only works on Firebase Hosting (has /__/auth/handler)
         * - Automatic redirect fallback would cause 404 on GitHub Pages
         * - Manual redirect button only appears where it can actually work
         * 
         * Error codes handled:
         * - auth/popup-blocked: Browser blocked the popup window
         * - auth/popup-closed-by-user: User closed popup before completing
         * - auth/cancelled-popup-request: Multiple popup requests, previous cancelled
         * - auth/network-request-failed: Network connectivity issues
         * 
         * @see canUseRedirectHandler
         * @see startRedirectLogin
         */
        async function signInWithGoogle() {
            try {
                showLoading('מתחבר עם Google...');
                await waitForFirebase();
                
                const provider = new window.firebaseGoogleAuthProvider();
                
                try {
                    // Try popup first
                    const result = await window.firebaseSignInWithPopup(auth, provider);
                    const user = result.user;
                    
                    // Save user data to Firestore
                    await saveUserToFirestore(user, user.email);
                    
                    hideLoading();
                    closeLoginModal();
                    showNotification('התחברת בהצלחה עם Google!', 'success');
                } catch (popupError) {
                    // If popup fails, DO NOT automatically redirect on GitHub Pages
                    // Only offer redirect as manual option if on Firebase hosting domain
                    if (popupError.code === 'auth/popup-blocked' || 
                        popupError.code === 'auth/popup-closed-by-user' ||
                        popupError.code === 'auth/cancelled-popup-request') {
                        console.warn('Popup failed or blocked:', popupError.code);
                        hideLoading();
                        
                        if (canUseRedirectHandler()) {
                            // Show redirect button for Firebase hosting domains
                            const redirectBtns = document.getElementsByClassName('redirect-login-btn');
                            for (let i = 0; i < redirectBtns.length; i++) {
                                redirectBtns[i].style.display = 'inline-block';
                            }
                            showNotification('הדפדפן חסם חלון קופץ. לחץ על הכפתור "התחבר באמצעות הפניה" למטה.', 'error');
                        } else {
                            // On GitHub Pages, redirect won't work - inform user
                            showNotification('הדפדפן חסם חלון קופץ. אנא אפשר חלונות קופצים בהגדרות הדפדפן ונסה שנית.', 'error');
                        }
                    } else {
                        throw popupError;
                    }
                }
            } catch (error) {
                hideLoading();
                console.error('Google sign-in error:', error);
                let errorMessage = 'שגיאה בהתחברות עם Google';
                if (error.code === 'auth/popup-closed-by-user') {
                    errorMessage = 'ההתחברות בוטלה';
                } else if (error.code === 'auth/popup-blocked') {
                    errorMessage = 'חלון ההתחברות נחסם. מנסה שיטה חלופית...';
                } else if (error.code === 'auth/cancelled-popup-request') {
                    errorMessage = 'בקשת התחברות בוטלה';
                } else if (error.code === 'auth/network-request-failed') {
                    errorMessage = 'שגיאת רשת. אנא בדוק את החיבור לאינטרנט';
                }
                showNotification(errorMessage, 'error');
            }
        }
        
        /**
         * Handle redirect result from Google sign-in
         * 
         * This function is called on page load to check if we're returning from
         * a redirect authentication flow. If a user successfully authenticated
         * via redirect, this will complete the login process.
         * 
         * NOTE: This will only work on Firebase Hosting domains where the
         * /__/auth/handler endpoint exists. On GitHub Pages, getRedirectResult()
         * will either return null or an error.
         * 
         * Flow:
         * 1. Check getRedirectResult() for pending authentication
         * 2. If user object exists: Complete login and save to Firestore
         * 3. If null: No redirect in progress (normal page load)
         * 4. If error: Log for debugging, show notification for real errors
         * 
         * @see startRedirectLogin
         */
        async function handleRedirectResult() {
            try {
                await waitForFirebase();
                const result = await window.firebaseGetRedirectResult(auth);
                
                if (result && result.user) {
                    showLoading('מסיים התחברות...');
                    const user = result.user;
                    
                    // Save user data to Firestore
                    await saveUserToFirestore(user, user.email);
                    
                    hideLoading();
                    showNotification('התחברת בהצלחה עם Google!', 'success');
                }
            } catch (error) {
                // Log all errors for debugging
                console.error('Redirect result error:', error);
                console.error('Error code:', error.code);
                console.error('Error message:', error.message);
                
                // Only show user-facing notifications for real errors, not expected states
                // auth/invalid-api-key might occur during initial page load before Firebase is ready
                if (error.code && error.code !== 'auth/invalid-api-key' && error.message) {
                    showNotification('שגיאה בהתחברות: ' + error.message, 'error');
                }
            }
        }
        
        /**
         * Register a new user with email and password
         */
        async function registerWithEmailPassword() {
            const emailInput = document.getElementById('registerEmailInput');
            const passwordInput = document.getElementById('registerPasswordInput');
            
            if (!emailInput || !passwordInput) return;
            
            const email = emailInput.value.trim();
            const password = passwordInput.value;
            
            if (!email || !password) {
                showNotification('אנא הזן אימייל וסיסמה', 'error');
                return;
            }
            
            if (password.length < 6) {
                showNotification('הסיסמה חייבת להכיל לפחות 6 תווים', 'error');
                return;
            }
            
            try {
                showLoading('מבצע רישום...');
                const user = await signUpWithEmail(email, password);
                
                // Save user data to Firestore
                await saveUserToFirestore(user, email);
                
                hideLoading();
                closeLoginModal();
                showNotification('רישום בוצע בהצלחה!', 'success');
            } catch (error) {
                hideLoading();
                console.error('Registration error:', error);
                let errorMessage = 'שגיאה ברישום';
                if (error.code === 'auth/email-already-in-use') {
                    errorMessage = 'המשתמש כבר קיים';
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = 'כתובת אימייל לא תקינה';
                } else if (error.code === 'auth/weak-password') {
                    errorMessage = 'הסיסמה חלשה מדי';
                }
                showNotification(errorMessage, 'error');
            }
        }
        
        /**
         * Login with existing email and password
         */
        async function loginWithEmailPassword() {
            const emailInput = document.getElementById('loginEmailInput');
            const passwordInput = document.getElementById('loginPasswordInput');
            
            if (!emailInput || !passwordInput) return;
            
            const email = emailInput.value.trim();
            const password = passwordInput.value;
            
            if (!email || !password) {
                showNotification('אנא הזן אימייל וסיסמה', 'error');
                return;
            }
            
            try {
                showLoading('מתחבר...');
                await signInWithEmail(email, password);
                hideLoading();
                closeLoginModal();
                showNotification('התחברת בהצלחה!', 'success');
            } catch (error) {
                hideLoading();
                console.error('Login error:', error);
                let errorMessage = 'שגיאה בהתחברות';
                if (error.code === 'auth/user-not-found') {
                    errorMessage = 'משתמש לא נמצא';
                } else if (error.code === 'auth/wrong-password') {
                    errorMessage = 'אימייל או סיסמה שגויים';
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = 'כתובת אימייל לא תקינה';
                }
                showNotification(errorMessage, 'error');
            }
        }
        
        /**
         * Legacy function for site password login (kept for compatibility with existing code)
         */
        async function loginWithSitePassword() {
            const email = document.getElementById('siteEmailInput') ? document.getElementById('siteEmailInput').value : '';
            const password = document.getElementById('sitePasswordInput') ? document.getElementById('sitePasswordInput').value : '';
            
            if (!email || !password) {
                alert('אנא מלא את כל השדות.');
                return;
            }
            
            try {
                // Use Firebase Auth instead of SimpleAuth
                await signInWithEmail(email, password);
                closeLoginModal();
            } catch (error) {
                console.error('Error during site password login:', error);
                alert('שגיאה בהתחברות: ' + error.message);
            }
        }
        
        /**
         * Deprecated: Email/password registration removed in favor of Google OAuth
         * This function is kept for backward compatibility but redirects to Google login
         * Will be removed in a future version
         */
        function registerWithEmail() {
            alert('אנא השתמש בכפתור "התחבר עם Google" להרשמה.');
        }
        
        /**
         * Deprecated: Legacy email/password login replaced with site password login
         * This function is kept for backward compatibility and calls the new implementation
         * Will be removed in a future version
         */
        function loginWithEmail() {
            loginWithSitePassword();
        }
        
        /**
         * Validates email address format
         * @param {string} email - Email address to validate
         * @returns {boolean} - True if email is valid, false otherwise
         */
        function isValidEmail(email) {
            // Email validation regex pattern
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            return emailRegex.test(email);
        }
        
        /**
         * Opens the unified Access Control modal on the Link Emails tab
         * This redirects to the unified modal for better UX
         */
        function openManageEmailsModal() {
            const user = auth?.currentUser;
            if (!user) {
                alert('אנא התחבר תחילה כדי לנהל כתובות מייל.');
                openLoginModal();
                return;
            }
            
            // Open the unified access control modal
            openAccessControlModal();
            // Switch to the link emails tab
            setTimeout(() => {
                switchAccessTab('linkEmails');
            }, 100);
        }
        
        /**
         * Closes the unified Access Control modal (replaces old Manage Emails modal)
         */
        function closeManageEmailsModal() {
            closeAccessControlModal();
        }
        
        /**
         * Loads and displays all currently linked authentication providers/emails
         * Shows which email addresses are currently linked to this null account
         */
        async function loadLinkedEmails() {
            const user = auth?.currentUser;
            if (!user) {
                return;
            }
            
            const linkedEmailsList = document.getElementById('linkedEmailsList');
            if (!linkedEmailsList) return;
            
            linkedEmailsList.innerHTML = '';
            
            // Get all linked providers
            const providerData = user.providerData;
            
            if (providerData && providerData.length > 0) {
                providerData.forEach(profile => {
                    const li = document.createElement('li');
                    li.style.cssText = 'padding: 8px 12px; margin-bottom: 8px; background: white; border-radius: 6px; border: 1px solid #d0e0ff; display: flex; align-items: center; gap: 10px;';
                    
                    // Determine provider icon using FontAwesome for cross-platform consistency
                    let iconClass = 'fas fa-envelope';
                    let iconColor = '#666';
                    let providerName = 'Email/Password';
                    if (profile.providerId === 'google.com') {
                        iconClass = 'fab fa-google';
                        iconColor = '#4285f4';
                        providerName = 'Google';
                    } else if (profile.providerId === 'password') {
                        iconClass = 'fas fa-key';
                        iconColor = '#f4b400';
                        providerName = 'Email/Password';
                    }
                    
                    li.innerHTML = `
                        <i class="${iconClass}" style="font-size: 1.2em; color: ${iconColor};"></i>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; color: #1f3b73;">${profile.email || 'לא זמין'}</div>
                            <div style="font-size: 0.8em; color: #666;">${providerName}</div>
                        </div>
                    `;
                    linkedEmailsList.appendChild(li);
                });
            } else {
                linkedEmailsList.innerHTML = '<li style="color: #888; font-style: italic;">אין כתובות מייל משויכות</li>';
            }
        }
        
        /**
         * Links a new email/password combination to the current user's account
         * Uses null linkWithCredential to add an additional authentication method
         * This allows users to sign in with multiple email addresses to the same account
         */
        async function linkNewEmail() {
            const user = auth?.currentUser;
            if (!user) {
                showLinkEmailStatus('אנא התחבר תחילה.', 'error');
                return;
            }
            
            const emailInput = document.getElementById('newLinkedEmail');
            const passwordInput = document.getElementById('newLinkedEmailPassword');
            
            if (!emailInput || !passwordInput) {
                console.error('Email/password input elements not found');
                showLinkEmailStatus('שגיאה: לא נמצאו שדות הקלט. נסה לרענן את הדף.', 'error');
                return;
            }
            
            const newEmail = emailInput.value.trim();
            const newPassword = passwordInput.value;
            
            // Validate inputs
            if (!newEmail || !newPassword) {
                showLinkEmailStatus('אנא מלא את כל השדות.', 'error');
                return;
            }
            
            // Validate email format using shared validation function
            if (!isValidEmail(newEmail)) {
                showLinkEmailStatus('כתובת המייל אינה תקינה.', 'error');
                return;
            }
            
            if (newPassword.length < 6) {
                showLinkEmailStatus('הסיסמה חייבת להיות לפחות 6 תווים.', 'error');
                return;
            }
            
            try {
                // Create email/password credential
                // This credential will be linked to the current user's account
                // Firebase credential removed
                
                // Link the credential to the current user
                // After this, the user can sign in with either the original method OR this new email/password
                // Both will authenticate to the same UID
                Promise.reject(new Error("Email linking removed"));
                
                // Success! Show success message
                showLinkEmailStatus(`✓ כתובת המייל ${newEmail} שויכה בהצלחה! עכשיו תוכל להתחבר עם מייל זה.`, 'success');
                
                // Clear form
                emailInput.value = '';
                passwordInput.value = '';
                
                // Reload the list of linked emails
                // Email linking removed
                
                console.log('Successfully linked new email:', newEmail);
            } catch (error) {
                console.error('Error linking new email:', error);
                
                // Handle specific error cases with user-friendly messages
                let errorMessage = 'שגיאה בשיוך המייל: ';
                
                if (error.code === 'auth/provider-already-linked') {
                    errorMessage += 'המייל כבר משויך לחשבון זה.';
                } else if (error.code === 'auth/email-already-in-use') {
                    errorMessage += 'כתובת המייל הזו כבר בשימוש בחשבון אחר. כל מייל יכול להיות משויך רק לחשבון אחד.';
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage += 'כתובת המייל אינה תקינה.';
                } else if (error.code === 'auth/weak-password') {
                    errorMessage += 'הסיסמה חלשה מדי. השתמש בסיסמה חזקה יותר.';
                } else if (error.code === 'auth/requires-recent-login') {
                    errorMessage += 'נדרשת התחברות מחודשת. אנא צא ממערכת והתחבר שוב, ולאחר מכן נסה שוב.';
                } else if (error.code === 'auth/credential-already-in-use') {
                    errorMessage += 'פרטי ההתחברות האלה כבר משויכים לחשבון אחר.';
                } else {
                    errorMessage += error.message || 'שגיאה לא ידועה.';
                }
                
                showLinkEmailStatus(errorMessage, 'error');
            }
        }
        
        /**
         * Shows a status message in the link email modal
         * @param {string} message - The message to display
         * @param {string} type - 'success' or 'error'
         */
        function showLinkEmailStatus(message, type) {
            const statusDiv = document.getElementById('linkEmailStatus');
            if (!statusDiv) return;
            
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
            
            if (type === 'success') {
                statusDiv.style.background = 'linear-gradient(135deg, #d4edda, #c3e6cb)';
                statusDiv.style.color = '#155724';
                statusDiv.style.border = '1px solid #c3e6cb';
            } else {
                statusDiv.style.background = 'linear-gradient(135deg, #f8d7da, #f5c6cb)';
                statusDiv.style.color = '#721c24';
                statusDiv.style.border = '1px solid #f5c6cb';
            }
            
            // Auto-hide success messages after 5 seconds
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }
        
        /**
         * Show a confirmation dialog (mobile-friendly alternative to confirm())
         * @param {string} message - The confirmation message
         * @param {string} title - Optional title (defaults to "אישור")
         * @returns {Promise<boolean>} - Resolves to true if confirmed, false otherwise
         */
        function showConfirmation(message, title = 'אישור') {
            return new Promise((resolve) => {
                try {
                    const modal = document.getElementById('confirmationModal');
                    const titleEl = document.getElementById('confirmationTitle');
                    const messageEl = document.getElementById('confirmationMessage');
                    const yesBtn = document.getElementById('confirmYesBtn');
                    const noBtn = document.getElementById('confirmNoBtn');
                    
                    if (!modal || !titleEl || !messageEl || !yesBtn || !noBtn) {
                        // Log specific missing elements for debugging
                        const missing = [];
                        if (!modal) missing.push('confirmationModal');
                        if (!titleEl) missing.push('confirmationTitle');
                        if (!messageEl) missing.push('confirmationMessage');
                        if (!yesBtn) missing.push('confirmYesBtn');
                        if (!noBtn) missing.push('confirmNoBtn');
                        console.error('Confirmation modal components not found:', missing.join(', '));
                        // Resolve to false (safer than true for confirmations)
                        resolve(false);
                        return;
                    }
                    
                    titleEl.textContent = title;
                    messageEl.textContent = message;
                    modal.style.display = 'flex';
                    
                    // Focus management - delay allows modal to render before focusing
                    // This prevents focus issues on slower devices
                    const FOCUS_DELAY_MS = 100;
                    setTimeout(() => noBtn.focus(), FOCUS_DELAY_MS);
                
                const cleanup = () => {
                    yesBtn.removeEventListener('click', handleYes);
                    noBtn.removeEventListener('click', handleNo);
                    modal.removeEventListener('keydown', handleKeyDown);
                };
                
                const handleYes = () => {
                    modal.style.display = 'none';
                    cleanup();
                    resolve(true);
                };
                
                const handleNo = () => {
                    modal.style.display = 'none';
                    cleanup();
                    resolve(false);
                };
                
                // Keyboard navigation: Escape to cancel, Tab trapping
                const handleKeyDown = (e) => {
                    if (e.key === 'Escape') {
                        handleNo();
                    } else if (e.key === 'Tab') {
                        // Tab trapping between the two buttons
                        const focusableElements = [yesBtn, noBtn];
                        const currentIndex = focusableElements.indexOf(document.activeElement);
                        
                        if (e.shiftKey) {
                            // Shift+Tab - go backwards
                            e.preventDefault();
                            const newIndex = currentIndex <= 0 ? focusableElements.length - 1 : currentIndex - 1;
                            focusableElements[newIndex].focus();
                        } else {
                            // Tab - go forwards
                            e.preventDefault();
                            const newIndex = currentIndex >= focusableElements.length - 1 ? 0 : currentIndex + 1;
                            focusableElements[newIndex].focus();
                        }
                    }
                };
                
                yesBtn.addEventListener('click', handleYes);
                noBtn.addEventListener('click', handleNo);
                modal.addEventListener('keydown', handleKeyDown);
                } catch (error) {
                    // Handle any unexpected errors during modal setup
                    console.error('Error showing confirmation modal:', error);
                    resolve(false);
                }
            });
        }
        
        /**
         * Generic confirmation dialog wrapper - alias for showConfirmation
         * @param {string} title - The dialog title
         * @param {string} message - The confirmation message
         * @param {Function} onConfirm - Callback function to execute on confirmation
         */
        async function openConfirmation(title, message, onConfirm) {
            const confirmed = await showConfirmation(message, title);
            if (confirmed && typeof onConfirm === 'function') {
                onConfirm();
            }
        }
        
        function isMobileViewport() {
            const hasCoarsePointer = window.matchMedia ? window.matchMedia('(pointer: coarse)').matches : false;
            const minDimension = Math.min(window.innerWidth, window.innerHeight);
            return (hasCoarsePointer || window.innerWidth <= 900) && minDimension <= 900;
        }
        
        // Initialize project details card position to prevent flickering on page load
        function initializeProjectDetailsCard() {
            if (!projectDetailsCard) return;
            
            // Temporarily disable transition
            projectDetailsCard.style.transition = 'none';
            
            if (isMobileViewport()) {
                // Mobile: hide card off-screen and keep invisible
                projectDetailsCard.style.left = '-280px';
                projectDetailsCard.style.pointerEvents = 'none';
                projectDetailsCard.style.visibility = 'hidden';
                cardOpen = false;
                setCardFabVisibility();
                updateCardFabState();
            } else {
                // Desktop: show card on screen
                projectDetailsCard.style.left = '15px';
                projectDetailsCard.style.pointerEvents = 'auto';
                projectDetailsCard.style.visibility = 'visible';
            }
            
            // Use requestAnimationFrame to restore transition
            requestAnimationFrame(() => {
                projectDetailsCard.style.transition = 'left 0.3s ease';
            });
        }
        
        function handleCardFabResize() {
            setCardFabVisibility();
            if (isMobileViewport()) {
                if (!cardOpen) {
                    projectDetailsCard.style.left = '-280px';
                    projectDetailsCard.style.pointerEvents = 'none';
                    projectDetailsCard.style.visibility = 'hidden';
                } else {
                    projectDetailsCard.style.visibility = 'visible';
                }
                updateCardFabState();
            } else {
                projectDetailsCard.style.pointerEvents = 'auto';
                projectDetailsCard.style.visibility = 'visible';
            }
        }
        function setCardFabVisibility() {
            if (!cardFab) return;
            // Show FAB on mobile, regardless of cardOpen state (icon changes, but button stays visible)
            const shouldShow = isMobileViewport();
            cardFab.style.display = shouldShow ? 'flex' : 'none';
        }
        
        // Helper function to hide card after slide-out animation
        function hideCardAfterDelay() {
            // Cancel any pending hide timeout to prevent race conditions
            // clearTimeout prevents the callback from running, so setting to null is safe
            if (cardHideTimeout) {
                clearTimeout(cardHideTimeout);
                cardHideTimeout = null;
            }
            
            // Schedule visibility hide after transition completes
            cardHideTimeout = setTimeout(() => {
                // Only hide if card is still closed and timeout wasn't canceled
                // If cardHideTimeout is null, it was canceled (clearTimeout was called)
                if (!cardOpen && cardHideTimeout) {
                    projectDetailsCard.style.visibility = 'hidden';
                    cardHideTimeout = null;
                }
            }, CARD_TRANSITION_DURATION);
        }
        
        // פונקציות הזזה לכרטיסיה במובייל
        function handleTouchStart(e) {
            if (!isMobileViewport()) return; // רק במובייל
            isDragging = true;
            startX = e.touches[0].clientX;
            currentX = startX;
            projectDetailsCard.style.transition = 'none'; // ביטול אנימציה במהלך הזזה
        }
        function handleTouchMove(e) {
            if (!isDragging || !isMobileViewport()) return;
            e.preventDefault();
            currentX = e.touches[0].clientX;
            const deltaX = currentX - startX;
            const newLeft = Math.min(15, Math.max(-280, 15 + deltaX)); // מגביל בין 15px ל- -280px
            projectDetailsCard.style.left = newLeft + 'px';
        }
        function handleTouchEnd(e) {
            if (!isDragging || !isMobileViewport()) return;
            isDragging = false;
            projectDetailsCard.style.transition = 'left 0.3s ease'; // הוספת אנימציה חזרה
            const deltaX = currentX - startX;
            if (deltaX > 50) {
                // פתח לגמרי אם הזיז ימינה מספיק
                if (cardHideTimeout) {
                    clearTimeout(cardHideTimeout);
                    cardHideTimeout = null;
                }
                projectDetailsCard.style.visibility = 'visible';
                projectDetailsCard.style.left = '15px';
                projectDetailsCard.style.pointerEvents = 'auto';
                cardOpen = true;
            } else if (deltaX < -50) {
                // סגור אם הזיז שמאלה מספיק
                projectDetailsCard.style.left = '-280px';
                projectDetailsCard.style.pointerEvents = 'none';
                cardOpen = false;
                hideCardAfterDelay();
            } else {
                // חזור למצב הקודם
                projectDetailsCard.style.left = cardOpen ? '15px' : '-280px';
                if (!cardOpen) {
                    hideCardAfterDelay();
                }
            }
            
            // Update icon based on final state
            const icon = document.getElementById('pullHandleIcon');
            if (icon) {
                icon.className = cardOpen ? 'fas fa-angle-double-left' : 'fas fa-angle-double-right';
            }
            updateCardFabState();
            setCardFabVisibility();
        }
        function updateCardFabState() {
            if (!cardFab) return;
            // Always update the entire button content to avoid stale references
            if (cardOpen) {
                cardFab.innerHTML = '<span class="card-fab-icon" aria-hidden="true">×</span><span class="sr-only">סגור כרטיס פרויקט</span>';
            } else {
                cardFab.innerHTML = '<img class="card-fab-icon" src="image_00b206.png" alt="" aria-hidden="true"><span class="sr-only">פתח כרטיס פרויקט</span>';
            }
            cardFab.setAttribute('aria-label', cardOpen ? 'סגור כרטיס פרויקט' : 'פתח כרטיס פרויקט');
        }
        function toggleCardFromFab() {
            toggleCard();
        }
        function toggleCard() {
            if (!isMobileViewport()) return; // רק במובייל
            cardOpen = !cardOpen;
            projectDetailsCard.style.transition = 'left 0.3s ease';
            
            if (cardOpen) {
                // Opening: Cancel any pending hide, make visible first, then slide in
                if (cardHideTimeout) {
                    clearTimeout(cardHideTimeout);
                    cardHideTimeout = null;
                }
                projectDetailsCard.style.visibility = 'visible';
                projectDetailsCard.style.left = '15px';
                projectDetailsCard.style.pointerEvents = 'auto';
            } else {
                // Closing: Slide out first, then hide after transition
                projectDetailsCard.style.left = '-280px';
                projectDetailsCard.style.pointerEvents = 'none';
                hideCardAfterDelay();
            }
            
            // Update icon direction
            const icon = document.getElementById('pullHandleIcon');
            if (icon) {
                icon.className = cardOpen ? 'fas fa-angle-double-left' : 'fas fa-angle-double-right';
            }
            updateCardFabState();
            setCardFabVisibility();
        }
        function closeCard() {
            if (!isMobileViewport()) return;
            cardOpen = false;
            projectDetailsCard.style.transition = 'left 0.3s ease';
            projectDetailsCard.style.left = '-280px';
            projectDetailsCard.style.pointerEvents = 'none';
            
            // Hide card after slide-out animation completes
            hideCardAfterDelay();
            
            // Update icon direction
            const icon = document.getElementById('pullHandleIcon');
            if (icon) {
                icon.className = 'fas fa-angle-double-right';
            }
            updateCardFabState();
            setCardFabVisibility();
        }
    </script>
    <script>
        // Stage Navigation Fix - Deterministic renderer (always shows 6 categories)
        // Uses global stagesConfig from main script to avoid duplication

        function getStageDefinitions() {
          // If stagesConfig is available globally, use it
          if (window.stagesConfig) {
            const stages = ['stage1', 'stage2', 'stage3', 'stage4', 'stage5', 'stage6'];
            return stages
              .filter(id => window.stagesConfig[id])
              .map(id => {
                const config = window.stagesConfig[id];
                return {
                  id,
                  longName: config.longName || config.name
                };
              });
          }
          
          // Fallback definitions if stagesConfig not available
          return [
            { id: 'stage1', longName: 'בציר' },
            { id: 'stage2', longName: 'ריסוק והכנה לתסיסה' },
            { id: 'stage3', longName: 'תסיסה אלכוהולית' },
            { id: 'stage4', longName: 'תסיסה מלולקטית' },
            { id: 'stage5', longName: 'יישון' },
            { id: 'stage6', longName: 'הכנה לבקבוק' }
          ];
        }

        function createButton(stage) {
          const btn = document.createElement('button');
          btn.className = 'stage-nav-button';
          btn.type = 'button';
          btn.textContent = stage.longName;
          btn.onclick = () => {
            if (typeof window.switchStage === 'function') {
              window.switchStage(stage.id);
            } else {
              console.log('[StageNavFix] Clicked:', stage.id, '(switchStage not available)');
            }
          };
          return btn;
        }

        let renderPending = false;

        function renderStageNavDeterministic() {
          const container = document.getElementById('stageNavContainer');
          if (!container) return;

          if (renderPending) return;
          renderPending = true;
          
          requestAnimationFrame(() => {
            const stages = getStageDefinitions();
            
            container.innerHTML = '';
            const rowLeft = document.createElement('div');
            const logoRow = document.createElement('div');
            logoRow.className = 'wine-icon-container';
            const rowRight = document.createElement('div');

            stages.slice(0, 3).forEach(s => rowLeft.appendChild(createButton(s)));
            
            const wineIconLink = document.createElement('a');
            wineIconLink.href = '#';
            wineIconLink.onclick = (e) => { e.preventDefault(); };
            const wineIconImg = document.createElement('img');
            wineIconImg.src = 'image_00b206.png';
            wineIconImg.alt = 'Wine Icon';
            wineIconLink.appendChild(wineIconImg);
            logoRow.appendChild(wineIconLink);
            
            stages.slice(3, 6).forEach(s => rowRight.appendChild(createButton(s)));

            container.appendChild(rowLeft);
            container.appendChild(logoRow);
            container.appendChild(rowRight);

            [rowLeft, logoRow, rowRight].forEach(el => {
              el.style.display = 'flex';
              el.style.visibility = 'visible';
            });
            
            renderPending = false;
          });
        }

        let observerActive = false;
        let observer = null;
        let visibilityHandler = null;
        let resizeHandler = null;

        function setupObserver() {
          const container = document.getElementById('stageNavContainer');
          if (!container || observerActive) return;

          const ensureSix = () => {
            if (renderPending) return;
            
            const buttons = container.querySelectorAll('.stage-nav-button');
            if (buttons.length !== 6) {
              console.warn('[StageNavFix] Buttons lost/incorrect count, re-rendering...');
              renderStageNavDeterministic();
            }
          };

          ensureSix();

          observer = new MutationObserver(ensureSix);
          observer.observe(container, { childList: true, subtree: true });
          observerActive = true;

          visibilityHandler = ensureSix;
          resizeHandler = ensureSix;
          
          document.addEventListener('visibilitychange', visibilityHandler);
          window.addEventListener('resize', resizeHandler);
        }

        function cleanup() {
          if (observer) {
            observer.disconnect();
            observer = null;
            observerActive = false;
          }
          
          if (visibilityHandler) {
            document.removeEventListener('visibilitychange', visibilityHandler);
            visibilityHandler = null;
          }
          if (resizeHandler) {
            window.removeEventListener('resize', resizeHandler);
            resizeHandler = null;
          }
        }

        function initStageNavFix() {
          renderStageNavDeterministic();
          setupObserver();
        }

        window.addEventListener('beforeunload', cleanup);

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initStageNavFix);
        } else {
          initStageNavFix();
        }
    </script>
    <script type="module">
  /*
   * FIREBASE AUTHENTICATION ON GITHUB PAGES - IMPLEMENTATION NOTES
   * ================================================================
   * 
   * This site is hosted on GitHub Pages (hidon1.github.io), which presents
   * specific challenges for Firebase Authentication redirect flows.
   * 
   * THE PROBLEM:
   * - Firebase Authentication's signInWithRedirect() requires a special handler
   *   endpoint at /__/auth/handler to complete the OAuth flow
   * - This endpoint only exists on Firebase Hosting domains (.web.app, .firebaseapp.com)
   * - GitHub Pages does not provide this endpoint, resulting in 404 errors
   * - Automatic fallback from popup to redirect was causing authentication failures
   * 
   * THE SOLUTION:
   * 1. Popup-First Approach: Always attempt signInWithPopup() first
   * 2. No Automatic Redirect: If popup fails, DO NOT automatically fall back to redirect
   * 3. Domain Detection: Use canUseRedirectHandler() to check if running on Firebase domain
   * 4. Manual Redirect Option: Show redirect button ONLY on Firebase domains
   * 5. Clear User Guidance: Inform users to enable popups when on GitHub Pages
   * 
   * KEY FUNCTIONS:
   * - canUseRedirectHandler(): Checks if /__/auth/handler is available
   * - startRedirectLogin(): Manual redirect (only on Firebase domains)
   * - signInWithGoogle(): Popup-first with smart fallback handling
   * 
   * This ensures authentication works reliably on both GitHub Pages (popup only)
   * and Firebase Hosting (popup + redirect option).
   */
  
  // Import Firebase SDKs
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-analytics.js";
  import { 
    getAuth, 
    createUserWithEmailAndPassword, 
    signInWithEmailAndPassword, 
    signOut as firebaseSignOut,
    onAuthStateChanged,
    GoogleAuthProvider,
    signInWithPopup,
    signInWithRedirect,
    getRedirectResult
  } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-auth.js";
  import { 
    getFirestore, 
    collection, 
    doc, 
    setDoc, 
    getDoc, 
    getDocs,
    updateDoc,
    deleteDoc,
    onSnapshot,
    serverTimestamp,
    query,
    where,
    orderBy
  } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-firestore.js";

  // Firebase configuration
  const firebaseConfig = {
    apiKey: "AIzaSyCKyhyXjm1J1I2Xf3ef6CgJlWD7Tm-ktBs",
    authDomain: "wine-cd8b9.firebaseapp.com",
    projectId: "wine-cd8b9",
    storageBucket: "wine-cd8b9.firebasestorage.app",
    messagingSenderId: "1021236266417",
    appId: "1:1021236266417:web:6da8f1f8e59da695aea990",
    measurementId: "G-G1523R5BXC"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
  const auth = getAuth(app);
  const db = getFirestore(app);

  // Make Firebase services globally available
  window.firebaseApp = app;
  window.firebaseAuth = auth;
  window.firebaseDb = db;
  window.firebaseAnalytics = analytics;
  
  // Firebase Authentication functions
  window.firebaseCreateUser = createUserWithEmailAndPassword;
  window.firebaseSignIn = signInWithEmailAndPassword;
  window.firebaseSignOut = firebaseSignOut;
  window.firebaseOnAuthStateChanged = onAuthStateChanged;
  window.firebaseGoogleAuthProvider = GoogleAuthProvider;
  window.firebaseSignInWithPopup = signInWithPopup;
  window.firebaseSignInWithRedirect = signInWithRedirect;
  window.firebaseGetRedirectResult = getRedirectResult;
  
  // Firestore functions
  window.firestoreCollection = collection;
  window.firestoreDoc = doc;
  window.firestoreSetDoc = setDoc;
  window.firestoreGetDoc = getDoc;
  window.firestoreGetDocs = getDocs;
  window.firestoreUpdateDoc = updateDoc;
  window.firestoreDeleteDoc = deleteDoc;
  window.firestoreOnSnapshot = onSnapshot;
  window.firestoreServerTimestamp = serverTimestamp;
  window.firestoreQuery = query;
  window.firestoreWhere = where;
  window.firestoreOrderBy = orderBy;

  console.log('Firebase initialized successfully');
</script>
</body>
</html>
